/**Description
Given a list of integers A, for each pair of integers (first, last) in list ranges, calculate the sum of the values in A between indices first and last (both inclusive), and return the greatest resulting sum.

Example
A = [1, -2, 3, 4, -5, -4, 3, 2, 1]
ranges = [(1, 3), (0, 4), (6, 8)]

result = 6
For ranges[0] = (1, 3) the sum is A[1] + A[2] + A[3] = 5
For ranges[1] = (0, 4) the sum is A[0] + A[1] + A[2] + A[3] + A[4] = 1
For ranges[2] = (6, 8) the sum is A[6] + A[7] + A[8] = 6
The greatest sum is 6
Notes
The list of ranges will never be empty;
This is a challenge version, you should implement an efficient algorithm to avoid timing out;
If this task is too difficult for you, try the simple version.
About random testcases
Small tests: 100 testcases
each integers-list : 5-100 elements
each ranges-list : 1-6 elements
Big tests: 100 testcases
each integers-list : 100000 element 
each ranges-list : 10000 elements */

function maxSum(arr,range){
    let left = [0]
    ,  total = 0;
    for (let num of arr)
      left.push(total += num);
    console.log(left)
  
    let sums = range.map(([a, b]) => {
  
      return left[b+1] - left[a]});
    
    return Math.max(...sums);
    }
/**https://www.codewars.com/kata/583d171f28a0c04b7c00009c/train/javascript/61143b7616f692001b9d4118 */



/**Create a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with empty elements.

Examples:

interleave([1, 2, 3], ["c", "d", "e"]) === [1, "c", 2, "d", 3, "e"]
interleave([1, 2, 3], [4, 5]) === [1, 4, 2, 5, 3, null]
interleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) === [1, 4, 7, 2, 5, 8, 3, 6, 9]
interleave([]) === [] */


function interleave () {
    let realArr = Array.from(arguments), maxLength = realArr[0].length, finalArr = []
    
    for (let i = 1; i < realArr.length; i++) {
        if (realArr[i].length > maxLength) {
            maxLength = realArr[i].length
        }
    }

    for (let i = 0; i < maxLength; i++) {
        for (const arr of realArr) {
            finalArr.push(i < arr.length ? arr[i] : null);
        }
    }
    return finalArr
}

//https://www.codewars.com/kata/523d2e964680d1f749000135/train/javascript/611429a391d9a3001ba82e0b


/**Implement a function that receives two IPv4 addresses, and returns the number of addresses between them (including the first one, excluding the last one).

All inputs will be valid IPv4 addresses in the form of strings. The last address will always be greater than the first one.

Examples
ipsBetween("10.0.0.0", "10.0.0.50")  ===   50 
ipsBetween("10.0.0.0", "10.0.1.0")   ===  256 
ipsBetween("20.0.0.10", "20.0.1.0")  ===  246 */

function ipsBetween(start, end) {
    start = start.split('.');
  
    return end.split('.').reduce(function(sum, x, i) {
      return (sum << 8) + Number(x) - Number(start[i])
    }, 0);
  }

  //https://www.codewars.com/kata/526989a41034285187000de4/train/javascript/611413a94f6bec005bace035


  /**Create a function that takes a positive integer and returns the next bigger number that can be formed by rearranging its digits. For example:

12 ==> 21
513 ==> 531
2017 ==> 2071
nextBigger(num: 12)   // returns 21
nextBigger(num: 513)  // returns 531
nextBigger(num: 2017) // returns 2071
If the digits can't be rearranged to form a bigger number, return -1 (or nil in Swift):

9 ==> -1
111 ==> -1
531 ==> -1
nextBigger(num: 9)   // returns nil
nextBigger(num: 111) // returns nil
nextBigger(num: 531) // returns nil */



function nextBigger(n){
    const arr = String(n).split('');
  
      for(let i = arr.length - 2; i >=0; i--){
          for(let j = arr.length - 1; j > i; j--){
              if(arr[i] < arr[j]){
                  let tmp = arr[i];
                  arr[i] = arr[j];
                  arr[j] = tmp;
                  let n = arr.splice(i+1).sort();
                  return +arr.concat(n).join('');
              }
          }
      }
      return -1;
  }

  //https://www.codewars.com/kata/55983863da40caa2c900004e/train/javascript/6113e15c0e51db003c5fc4f4


  /**Complete the solution so that it strips all text that follows any of a set of comment markers passed in. Any whitespace at the end of the line should also be stripped out.

Example:

Given an input string of:

apples, pears # and bananas
grapes
bananas !apples
The output expected would be:

apples, pears
grapes
bananas
The code would be called like so:

var result = solution("apples, pears # and bananas\ngrapes\nbananas !apples", ["#", "!"])
// result should == "apples, pears\ngrapes\nbananas" */

//Solution #2
function solution(input, markers)
{
  var lines = input.split("\n");
  for (var i = 0; i < lines.length; i++)
    for (var j = 0; j < markers.length; j++)
      {
        let endline = lines[i].indexOf(markers[j]) >= 0 ? lines[i].indexOf(markers[j]) -1 : lines[i].length;
        lines[i] = lines[i].slice(0,endline);
        }
  return lines.join("\n");

}


//Solution #1
function solution(input, markers)
{
  var lines = input.split("\n");
  for (var i = 0; i < lines.length; ++i)
    for (var j = 0; j < markers.length; ++j)
      lines[i] = lines[i].split(markers[j])[0].trim();
  return lines.join("\n");
}

//https://www.codewars.com/kata/51c8e37cee245da6b40000bd/train/javascript/6113bb8637b4ec005b64f334


/** Snail Sort
Given an n x n array, return the array elements arranged from outermost elements to the middle element, traveling clockwise.

array = [[1,2,3],
         [4,5,6],
         [7,8,9]]
snail(array) #=> [1,2,3,6,9,8,7,4,5]
For better understanding, please follow the numbers of the next array consecutively:

array = [[1,2,3],
         [8,9,4],
         [7,6,5]]
snail(array) #=> [1,2,3,4,5,6,7,8,9]
This image will illustrate things more clearly:


NOTE: The idea is not sort the elements from the lowest value to the highest; the idea is to traverse the 2-d array in a clockwise snailshell pattern.

NOTE 2: The 0x0 (empty matrix) is represented as en empty array inside an array [[]].*/

//Solution #2
function snail(array) {
    var vector = [];
    while (array.length) {
      vector.push(...array.shift());
      array.map(row => vector.push(row.pop()));
      array.reverse().map(row => row.reverse());
    }
    return vector;
  }

  //Solution #1
snail = function(arr) {
    var result = [];
    var top = 0, bottom = arr.length-1;
    var left = 0, right = arr[0].length-1;
  
    do {
      for (var i = left; i <= right; i++){result.push(arr[top][i])} // top row
      for (var i = top+1; i <= bottom; i++){result.push(arr[i][right])} // right column
      for (var i = right-1; i >= left; i--){result.push(arr[bottom][i])} // bottom row
      for (var i = bottom-1; i > top; i--){result.push(arr[i][left])} // left column
      top++; bottom--; left++; right--;
    } while (top <= bottom);
  
    return result;
  }
  //https://www.codewars.com/kata/521c2db8ddc89b9b7a0000c1/train/javascript/6112d672da33cb002e3e1b50

  /**The learning game - Machine Learning #1
Growing up you would have learnt a lot of things like not to stand in fire, to drink food and eat water and not to jump off very tall things But Machines have it difficult they cannot learn for themselves we have to tell them what to do, why don't we give them a chance to learn it for themselves?

Task
Your task is to finish the Machine object. What the machine object must do is learn from its mistakes! The Machine will be given a command and a number you will return a random action. After the command has returned you will be given a response (true/false) if the response is true then you have done good, if the response is false then the action was a bad one. You must program the machine to learn to apply an action to a given command using the reponse given. Note: It must take no more than 20 times to teach an action to a command also different commands can have the same action.

Info
In the preloaded section there is a constant called ACTIONS it is a function that returns the 5 possible actions.
In Java, this a constant Actions.FUNCTIONS of type List<Function<Integer, Integer>>.
In C++, the actions can be accessed by get_action(i)(unsigned int num) where i chooses the function (and therefore can range from 0 to 4) and num is its argument.
In python ACTIONS() returns a list of lambdas.
In Golang Actions() retruns a function slice []func(int) int */


class Machine {

    constructor () {
      this._cmd = null;
      this._map = {};
    }
  
    command (cmd, num) {
      this._cmd = cmd;
      this._map[cmd] = this._map[cmd] || ACTIONS();
      return this._map[cmd][0](num);
    }
  
    response (resp) {
      resp || this._map[this._cmd].shift();
    }
   
  }
//https://www.codewars.com/kata/5695995cc26a1e90fe00004d/train/javascript/61129645f983f20021cc818b


/**Your task in order to complete this Kata is to write a function which formats a duration, given as a number of seconds, in a human-friendly way.

The function must accept a non-negative integer. If it is zero, it just returns "now". Otherwise, the duration is expressed as a combination of years, days, hours, minutes and seconds.

It is much easier to understand with an example:

formatDuration(62)    // returns "1 minute and 2 seconds"
formatDuration(3662)  // returns "1 hour, 1 minute and 2 seconds"
For the purpose of this Kata, a year is 365 days and a day is 24 hours.

Note that spaces are important.

Detailed rules
The resulting expression is made of components like 4 seconds, 1 year, etc. In general, a positive integer and one of the valid units of time, separated by a space. The unit of time is used in plural if the integer is greater than 1.

The components are separated by a comma and a space (", "). Except the last component, which is separated by " and ", just like it would be written in English.

A more significant units of time will occur before than a least significant one. Therefore, 1 second and 1 year is not correct, but 1 year and 1 second is.

Different components have different unit of times. So there is not repeated units like in 5 seconds and 1 second.

A component will not appear at all if its value happens to be zero. Hence, 1 minute and 0 seconds is not valid, but it should be just 1 minute.

A unit of time must be used "as much as possible". It means that the function should not return 61 seconds, but 1 minute and 1 second instead. Formally, the duration specified by of a component must not be greater than any valid more significant unit of time. */


function formatDuration (seconds) {
    if (seconds === 0) {
        return 'now';
    }

    let years = seconds / (365 * 24 * 60 * 60);
    years = Math.trunc(years);
    seconds -= years * 365 * 24 * 60 * 60;
    let days = seconds / (24 * 60 * 60);
    days = Math.trunc(days);
    seconds -= days * 24 * 60 * 60;
    let hours = seconds / (60 * 60);
    hours = Math.trunc(hours);
    seconds -= hours * 60 * 60;
    let minutes = seconds / 60;
    minutes = Math.trunc(minutes);
    seconds -= minutes * 60;

    let result = "";
    if (years !== 0) {
        if (years === 1) {
            result += years + " year, ";
        } else {
            result += years + " years, ";
        }
    }
    if (days !== 0) {
        if (days === 1) {
            result += days + " day, ";
        } else {
            result += days + " days, ";
        }
    }
    if (hours !== 0) {
        if (hours === 1) {
            result += hours + " hour, ";
        } else {
            result += hours + " hours, ";
        }
    }
    if (minutes !== 0) {
        if (minutes === 1) {
            result += minutes + " minute, ";
        } else {
            result += minutes + " minutes, ";
        }
    }
    if (seconds !== 0) {
        if (seconds === 1) {
            result += seconds + " second, ";
        } else {
            result += seconds + " seconds, ";
        }
    }

    result = result.slice(0, result.length - 2);
    let n = result.lastIndexOf(',');
    if (n >= 0) {
        result = result.substr(0, n) + ' and' +
            result.substr(n + 1, result.length);
    }

    return result;
}

//https://www.codewars.com/kata/52742f58faf5485cae000b9a/train/javascript/61129914cfceca003e0d1c2d

/**Jon and Joe have received equal marks in the school examination. But, they won't reconcile in peace when equated with each other. To prove his might, Jon challenges Joe to write a program to find all possible number combos that sum to a given number. While unsure whether he would be able to accomplish this feat or not, Joe accpets the challenge. Being Joe's friend, your task is to help him out.

Task
Create a function combos, that accepts a single positive integer num (30 > num > 0) and returns an array of arrays of positive integers that sum to num.

Notes
Sub-arrays may or may not have their elements sorted.
The order of sub-arrays inside the main array does not matter.
For an optimal solution, the following operation should complete within 6000ms.
Sample
    combos(3) => [ [ 3 ], [ 1, 1, 1 ], [ 1, 2 ] ]
    combos(10) => [ [ 10 ],
      [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
        [ 1, 1, 1, 1, 1, 1, 1, 1, 2 ],
        [ 1, 1, 1, 1, 1, 1, 1, 3 ],
        [ 1, 1, 1, 1, 1, 1, 4 ],
        [ 1, 1, 1, 1, 1, 5 ],
        [ 1, 1, 1, 1, 6 ],
        [ 1, 1, 1, 7 ],
        [ 1, 1, 8 ],
        [ 1, 9 ],
        [ 1, 1, 1, 1, 1, 1, 2, 2 ],
        [ 1, 1, 1, 1, 1, 2, 3 ],
        [ 1, 1, 1, 1, 2, 4 ],
        [ 1, 1, 1, 1, 2, 2, 2 ],
        [ 1, 1, 1, 1, 3, 3 ],
        [ 1, 1, 1, 2, 5 ],
        [ 1, 1, 1, 2, 2, 3 ],
        [ 1, 1, 1, 3, 4 ],
        [ 1, 1, 2, 6 ],
        [ 1, 1, 2, 2, 4 ],
        [ 1, 1, 2, 2, 2, 2 ],
        [ 1, 1, 2, 3, 3 ],
        [ 1, 1, 3, 5 ],
        [ 1, 1, 4, 4 ],
        [ 1, 2, 7 ],
        [ 1, 2, 2, 5 ],
        [ 1, 2, 2, 2, 3 ],
        [ 1, 2, 3, 4 ],
        [ 1, 3, 6 ],
        [ 1, 3, 3, 3 ],
        [ 1, 4, 5 ],
        [ 2, 8 ],
        [ 2, 2, 6 ],
        [ 2, 2, 2, 4 ],
        [ 2, 2, 2, 2, 2 ],
        [ 2, 2, 3, 3 ],
        [ 2, 3, 5 ],
        [ 2, 4, 4 ],
        [ 3, 7 ],
        [ 3, 3, 4 ],
        [ 4, 6 ],
        [ 5, 5 ] ] */


        function combos(number) {
            var results = [];
            
            (function partition(num, max = num, arr = []) {
              if (num === 0) {
                results.push(arr);
                return;
              }
              for (var i = Math.min(max, num); i >= 1; i--) {
                partition(num - i, i, [...arr, i]);
              }
            })(number);
            
            return results;
          }    
//https://www.codewars.com/kata/555b1890a75b930e63000023/train/javascript/61129348f983f2000ecc12f0

/**With your birthday coming up soon, your eccentric friend sent you a message to say "happy birthday":

hhhappyyyy biirrrrrthddaaaayyyyyyy to youuuu
hhapppyyyy biirtttthdaaay too youuu
happy birrrthdayy to youuu
happpyyyy birrtthdaaay tooooo youu
At first it looks like a song, but upon closer investigation, you realize that your friend hid the phrase "happy birthday" thousands of times inside his message. In fact, it contains it more than 2 million times! To thank him, you'd like to reply with exactly how many times it occurs.

To count all the occurences, the procedure is as follows: look through the paragraph and find a 'h'; then find an 'a' later in the paragraph; then find an 'p' after that, and so on. Now count the number of ways in which you can choose letters in this way to make the full phrase.

More precisely, given a text string, you are to determine how many times the search string appears as a sub-sequence of that string.

Write a function called countSubsequences that takes two arguments: needle, the string to be search for and haystack, the string to search in. In our example, "happy birthday" is the needle and the birthday message is the haystack. The function should return the number of times needle occurs as a sub-sequence of haystack. Spaces are also considered part of the needle.

Since the answers can be very large, return only the last 8 digits of the answer in case it exceeds 8 digits. The answers to the test cases will all be shorter than 8 digits. */


function countSubsequences(needle, haystack) {
    // returns the number of subsequences as an integer
    // write your solution here ... 
    needle = needle.trim();
    haystack = haystack.trim();
    return helper(needle,haystack, needle.length-1, haystack.length-1);
  }
  //i is index in sub
  //j is index in str
  function helper(sub, str, i, j){
    if(i < 0) return 1; // we found an occurence
    if(j < 0) return 0; //we are at the end of the string
    if(sub[i] === str[j]){
      return helper(sub,str,i-1,j-1)+helper(sub,str,i,j-1);
    }else{
      return helper(sub,str,i,j-1);
    }
  }
  //https://www.codewars.com/kata/52f7892a747862fc9a0009a6/train/javascript/61127f64244632002ce3107c


  /**This kata explores writing an AI for a two player, turn based game called NIM.

The Board
The board starts out with several piles of straw. Each pile has a random number of straws.

Pile 0: ||||

Pile 1: ||

Pile 2: |||||

Pile 3: |

Pile 4: ||||||

...or more concisely: [4,2,5,1,6]
The Rules
The players take turns picking a pile, and removing any number of straws from the pile they pick
A player must pick at least one straw
If a player picks the last straw, she wins!
The Task
In this kata, you have to write an AI to play the straw picking game.

You have to encode an AI in a function choose_move (or chooseMove, or choose-move) that takes a board, represented as a list of positive integers, and returns

[pile_index, number_of_straws]
Which refers to an index of a pile on the board, and some none-zero number of straws to draw from that pile.

The test suite is written so that your AI is expected to play 50 games and win every game it plays. */

function chooseMove(state) {
    function getMaxOfArray(numArray) {
      return Math.max.apply(null, numArray);
    }
    let result, position;
    for (let i = 0; i < state.length; i++) {
      result = 0;
      for (let j = 0; j < state.length; j++) {
        if (i == j) continue;
        result = state[j]^result;
      }
      if (result < state[i]) {
        position = i;
        break;
      }
    }
    return [position, state[position] - result];
  }

  //https://www.codewars.com/kata/54120de842dff35232000195/train/javascript/61127ec9dd352a00203d2522

  /**Connect Four
Take a look at wiki description of Connect Four game:

Wiki Connect Four

The grid is 6 row by 7 columns, those being named from A to G.

You will receive a list of strings showing the order of the pieces which dropped in columns:

  piecesPositionList = ["A_Red",
                        "B_Yellow",
                        "A_Red",
                        "B_Yellow",
                        "A_Red",
                        "B_Yellow",
                        "G_Red",
                        "B_Yellow"]
The list may contain up to 42 moves and shows the order the players are playing.

The first player who connects four items of the same color is the winner.

You should return "Yellow", "Red" or "Draw" accordingly. */

function connectFour(field, i, j) {
    const directions = [
        [0, 1], //left to right
        [1, 0], //top to bottom
        [1, 1], //diagonal left to right
        [1, -1], //diagonal right to left
    ];

    for (const [kInc, nInc] of directions) {
        for (
            let k = i, n = j;
            k < 7 && field[k][n] === field[i][j];
            k += kInc, n += nInc
        ) {
            if (k - i === 3 || n - j === 3) return field[i][j];
        }
    }
}

function checkForWinner(field) {
    for (let i = 0; i < field.length; ++i) {
        for (let j = 0; j < field[i].length; ++j) {
            let winner = connectFour(field, i, j);
            if (winner) return winner;
        }
    }
}

function whoIsWinner(piecesPositionList) {
    let field = [[], [], [], [], [], [], []],
        winner;

    for (const val of piecesPositionList) {
        //UTF-16 code for 'A' is 65
        field[val.charCodeAt(0) - 65].push(val.slice(2));
        if ((winner = checkForWinner(field))) break;
    }

    return winner || "Draw";
}
//https://www.codewars.com/kata/56882731514ec3ec3d000009/train/javascript/61127c3e244632002ce2cdaf



/**My friend John and I are members of the "Fat to Fit Club (FFC)". John is worried because each month a list with the weights of members is published and each month he is the last on the list which means he is the heaviest.

I am the one who establishes the list so I told him: "Don't worry any more, I will modify the order of the list". It was decided to attribute a "weight" to numbers. The weight of a number will be from now on the sum of its digits.

For example 99 will have "weight" 18, 100 will have "weight" 1 so in the list 100 will come before 99.

Given a string with the weights of FFC members in normal order can you give this string ordered by "weights" of these numbers?

Example:
"56 65 74 100 99 68 86 180 90" ordered by numbers weights becomes: 

"100 180 90 56 65 74 68 86 99"
When two numbers have the same "weight", let us class them as if they were strings (alphabetical ordering) and not numbers:

180 is before 90 since, having the same "weight" (9), it comes before as a string.

All numbers in the list are positive numbers and the list can be empty.

Notes
it may happen that the input string have leading, trailing whitespaces and more than a unique whitespace between two consecutive numbers
For C: The result is freed. */

function orderWeight(string) {
    var arr=string.split(' ');
    arr.sort(function(a,b){
      var num1=0;
      var num2=0;
      for(var i=0;i<a.length;i++)num1+=a[i]*1;
      for(var i=0;i<b.length;i++)num2+=b[i]*1;
      return num1-num2||a.localeCompare(b);
    })
    return arr.join(' ')
}

//https://www.codewars.com/kata/55c6126177c9441a570000cc/train/javascript/610d861448247e00578787f1


/**In mathematics, a Diophantine equation is a polynomial equation, usually with two or more unknowns, such that only the integer solutions are sought or studied.

In this kata we want to find all integers x, y (x >= 0, y >= 0) solutions of a diophantine equation of the form:

x2 - 4 * y2 = n
(where the unknowns are x and y, and n is a given positive number) in decreasing order of the positive xi.

If there is no solution return [] or "[]" or "". (See "RUN SAMPLE TESTS" for examples of returns).

Examples:
solEquaStr(90005) --> "[[45003, 22501], [9003, 4499], [981, 467], [309, 37]]"
solEquaStr(90002) --> "[]"
Hint:
x2 - 4 * y2 = (x - 2*y) * (x + 2*y) */


function solequa(n) {
    let divs = [];
    
    for(let i = 1; i <= Math.sqrt(n); i++) {
      if(n%i == 0 && !((n/i + i) % 2) && !((n/i - i) % 4)) {
        divs.push([i, n/i]);
      }
    }
  
    return divs.map((_, i) => {
      let x = (divs[i][1] + divs[i][0])/2;
      let y = (divs[i][1] - divs[i][0])/4;
      return [x,y];
    });
  }

  //https://www.codewars.com/kata/554f76dca89983cc400000bb/train/javascript/6112702de1a9d500327686e3



  /**Help the frog to find a way to freedom
You have an array of integers and have a frog at the first position

[Frog, int, int, int, ..., int]

The integer itself may tell you the length and the direction of the jump

For instance:
 2 = jump two indices to the right
-3 = jump three indices to the left
 0 = stay at the same position
Your objective is to find how many jumps are needed to jump out of the array.

Return -1 if Frog can't jump out of the array

Example:
array = [1, 2, 1, 5]; 
jumps = 3  (1 -> 2 -> 5 -> <jump out>)
All tests for this Kata are randomly generated. */

function solution(a) {
    if (a.length === 0) return -1
    let count=0;
    for (let i=0;i<a.length;i+=a[i]){
    if (i < 0){
      break;
    }
    count++
    if (count>500){
      return -1;
    }
    }
    return count
  }
  //https://www.codewars.com/kata/536950ffc8a5ca9982001371/train/javascript/61119d2ec376df00462d3091


  /**Complete the function that takes a non-negative integer, and returns a list of non-negative integer pairs whose values - when squared - sum to the given integer.

For example, given the parameter 25, the function should return the two pairs [0, 5] and [3, 4] because 0^2 + 5^2 = 25 and 3^2 + 4^2 = 25.

Return the pairs in ascending order, so e.g. [[0, 5], [3, 4]] not [[5, 0], [3, 4]] or [[3, 4], [0, 5]], etc.

If the given value cannot be expressed as the sum of two squares, return an empty array.

Note: The upper bound of the parameter value will be 2,147,483,647

Examples
  0  -->  [ [0, 0] ]
  1  -->  [ [0, 1] ]
  2  -->  [ [1, 1] ]
  3  -->  []
  4  -->  [ [0, 2] ]
  5  -->  [ [1, 2] ]
 25  -->  [ [0, 5], [3, 4] ]
325  -->  [ [1, 18], [6, 17], [10, 15] ] */



function allSquaredPairs(num) {
    let pairs = [];
    for (var i = 0; i <= Math.sqrt(num/2); i++) {
      let j = Math.sqrt(num-i*i);
      if (j % 1 == 0) {
        pairs.push([i, j]);
      }
    }
    return pairs;
  }

  //https://www.codewars.com/kata/52217066578afbcc260002d0/train/javascript/60f801baca1ef90031332270


  /**When working with color values it can sometimes be useful to extract the individual red, green, and blue (RGB) component values for a color. Implement a function that meets these requirements:

Accepts a case-insensitive hexadecimal color string as its parameter (ex. "#FF9933" or "#ff9933")
Returns a Map<String, int> with the structure {r: 255, g: 153, b: 51} where r, g, and b range from 0 through 255
Note: your implementation does not need to support the shorthand form of hexadecimal notation (ie "#FFF")

Example
"#FF9933" --> {r: 255, g: 153, b: 51} */
function hexStringToRGB(h) {
    console.log(h.slice(0,3))
    return {
      r: parseInt(h.slice(1,3), 16),
      g: parseInt(h.slice(3,5), 16),
      b: parseInt(h.slice(5,7), 16)
  }
  }

  //https://www.codewars.com/kata/5282b48bb70058e4c4000fa7/train/javascript/61111275bc9894000eea135c


  /**Sort the given array of strings in alphabetical order, case insensitive. For example:

["Hello", "there", "I'm", "fine"]  -->  ["fine", "Hello", "I'm", "there"]
["C", "d", "a", "B"])              -->  ["a", "B", "C", "d"] */

sortme = function( names ){
    return names.sort((a,b) => {
        if (a.toLowerCase() < b.toLowerCase()) return -1;
        if (a.toLowerCase() > b.toLowerCase()) return 1;
    })
}

//https://www.codewars.com/kata/51f41fe7e8f176e70d0002b9/train/javascript/61118329f35f3000333c3419

/**1, 246, 2, 123, 3, 82, 6, 41 are the divisors of number 246. Squaring these divisors we get: 1, 60516, 4, 15129, 9, 6724, 36, 1681. The sum of these squares is 84100 which is 290 * 290.

Task
Find all integers between m and n (m and n integers with 1 <= m <= n) such that the sum of their squared divisors is itself a square.

We will return an array of subarrays or of tuples (in C an array of Pair) or a string. The subarrays (or tuples or Pairs) will have two elements: first the number the squared divisors of which is a square and then the sum of the squared divisors.

Example:
list_squared(1, 250) --> [[1, 1], [42, 2500], [246, 84100]]
list_squared(42, 250) --> [[42, 2500], [246, 84100]]
The form of the examples may change according to the language, see "Sample Tests".

Note
In Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use dynamically allocated character strings. */

function listSquared(m, n) {
    let arr = []
    for (let i = m; i <= n; i++) {
        let temp = 0;
        for (let j = 1; j <= i; j++) {
            if (i % j == 0) {
                temp += j*j;
            } 
        }
        if(Math.sqrt(temp) % 1 == 0) {
                arr.push([i, temp]);
            }
    }
    return arr;
}
//https://www.codewars.com/kata/55aa075506463dac6600010d/train/javascript/611180dc06abc70032898d25


/**If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in.

Note: If the number is a multiple of both 3 and 5, only count it once. Also, if a number is negative, return 0(for languages that do have them) */


function solution(number){
    let arr = [];
    let multiple = [];
    
    // push all num between 0 and the number to arr
    for (let i = 0; i < number; i++) {
      arr.push(i);
    }
    
    // if number in arr is a multiple or 3 or 5 push it to multiple
    for (let i = 0; i < arr.length; i++) {
      if (i % 3 === 0 || i % 5 === 0) {
        multiple.push(i);
      }
    }
    
    // sum the total of the multiple array
    const sumTotal = multiple.reduce((sum, num) => sum + num, 0);
    
    return sumTotal;
  }

  //https://www.codewars.com/kata/514b92a657cdc65150000006/train/javascript/6111802406abc700078acedf


  /**Given a name, turn that name into a perfect square matrix (nested array with the amount of arrays equivalent to the length of each array).

You will need to add periods (.) to the end of the name if necessary, to turn it into a matrix.

If the name has a length of 0, return "name must be at least one letter"

Examples
"Bill" ==> [ ["B", "i"],
             ["l", "l"] ]

"Frank" ==> [ ["F", "r", "a"],
              ["n", "k", "."],
              [".", ".", "."] ] */

              const matrixfy = str => {
  
                if (str.length == 0) {
                    return 'name must be at least one letter';
                  }
                
                const len = Math.ceil(Math.sqrt(str.length));
                let counter = 0;
                str = str.split('');
                let arr = [];
                
                for(let i = 0; i < len;i++){
                  arr.push([]);
                  
                  for(let j = 0; j < len;j++){
                     
                    if(counter >= str.length)
                    {
                      arr[i].push(".");
                    } 
                    else
                    {
                      arr[i].push(str[counter++]);
                    }
                      
                    }
                  }
                console.log(arr);
                return arr;
              }
//https://www.codewars.com/kata/5a91e0793e9156ccb0003f6e/train/javascript/611154ccc376df0046277638 


/**Write a function that accepts two square matrices (N x N two dimensional arrays), and return the sum of the two. Both matrices being passed into the function will be of size N x N (square), containing only integers.

How to sum two matrices:

Take each cell [n][m] from the first matrix, and add it with the same [n][m] cell from the second matrix. This will be cell [n][m] of the solution matrix.

Visualization:

|1 2 3|     |2 2 1|     |1+2 2+2 3+1|     |3 4 4|
|3 2 1|  +  |3 2 3|  =  |3+3 2+2 1+3|  =  |6 4 4|
|1 1 1|     |1 1 3|     |1+1 1+1 1+3|     |2 2 4| */

function matrixAddition(a, b){
    let arr = a;
    for(let i =0; i <a.length;i++){
      for(let j =0; j <a[i].length;j++){
      arr[i][j] = a[i][j] + b[i][j] ;
      }
    }
    return arr;
    
  }
  //https://www.codewars.com/kata/526233aefd4764272800036f/train/javascript/61114f18bc98940056ef574e


  /**The marketing team is spending way too much time typing in hashtags.
Let's help them with our own Hashtag Generator!

Here's the deal:

It must start with a hashtag (#).
All words must have their first letter capitalized.
If the final result is longer than 140 chars it must return false.
If the input or the result is an empty string it must return false.
Examples
" Hello there thanks for trying my Kata"  =>  "#HelloThereThanksForTryingMyKata"
"    Hello     World   "                  =>  "#HelloWorld"
""                                        =>  false */
function generateHashtag(str) {
    if (!/\w/.test(str)) return false;
    let arr = str.split(" ");
    arr.forEach((el, i) => {
      arr[i] = el.charAt(0).toUpperCase() + el.slice(1);
    });
    let res = "#" + arr.join("");
    return res.length > 140 ? false : res;
  }

  //https://www.codewars.com/kata/52449b062fb80683ec000024/train/javascript/61114ab30e7e9400427f2ae6


  /**Description
In her trip to Italy, Elizabeth Gilbert made it her duty to eat perfect pizza. One day, she ordered one for dinner. And then some Italian friends appeared at her room.

The problem is that there were many people who ask for a piece of pizza at that moment. And she had a knife that only cuts straight.

Given a number K (K<=45000), help her get the maximum number of pieces possible (not necessarily of equal size) with K cuts. If K is a negative number, the result must be -1 (or Nothing in Haskell).

Examples
maxPizza(0) == 1
maxPizza(1) == 2
maxPizza(3) == 7 */
function maxPizza(cut) {
    if (cut < 0)     return -1
    else if (cut == 0) return 1
    return (cut*(cut+1)/2)+1
}
//https://www.codewars.com/kata/5551dc71101b2cf599000023/train/javascript/611119b2bc98940007ea9c64

/**Complete the solution so that it returns true if it contains any duplicate argument values. Any number of arguments may be passed into the function.

The array values passed in will only be strings or numbers. The only valid return values are true and false.

Examples:

solution(1, 2, 3)             -->  false
solution(1, 2, 3, 2)          -->  true
solution('1', '2', '3', '2')  -->  true */


function solution(...arr){
    return [...new Set(arr)].length!=arr.length
   }
   //https://www.codewars.com/kata/520d9c27e9940532eb00018e/train/javascript/61111877a56d3300327a19e6


/**Write a module Converter that can take ASCII text and convert it to hexadecimal. The class should also be able to take hexadecimal and convert it to ASCII text.

Example
Converter.toHex("Look mom, no hands")
=> "4c6f6f6b206d6f6d2c206e6f2068616e6473"

Converter.toAscii("4c6f6f6b206d6f6d2c206e6f2068616e6473")
=> "Look mom, no hands" */
var Converter = {
    toAscii: function (hex) {
      let arr=[];
      for (let i=0;i<hex.length;i+=2){
          arr.push(hex.slice(i,i+2))
        }
      return arr.map(v=>String.fromCharCode(parseInt(v,16))).join('')
    },
    toHex: function (ascii) {
       return ascii.split('').map(v=>v.charCodeAt().toString(16)).join('')
    }
  }
  //https://www.codewars.com/kata/52fea6fd158f0576b8000089/train/javascript/6111178f57fd1400085d2ae7

  /**Complete the function/method (depending on the language) to return true/True when its argument is an array that has the same nesting structures and same corresponding length of nested arrays as the first array.

For example:

 // should return true
[ 1, 1, 1 ].sameStructureAs( [ 2, 2, 2 ] );          
[ 1, [ 1, 1 ] ].sameStructureAs( [ 2, [ 2, 2 ] ] );  

 // should return false 
[ 1, [ 1, 1 ] ].sameStructureAs( [ [ 2, 2 ], 2 ] );  
[ 1, [ 1, 1 ] ].sameStructureAs( [ [ 2 ], 2 ] );  

// should return true
[ [ [ ], [ ] ] ].sameStructureAs( [ [ [ ], [ ] ] ] ); 

// should return false
[ [ [ ], [ ] ] ].sameStructureAs( [ [ 1, 1 ] ] );     
For your convenience, there is already a function 'isArray(o)' declared and defined that returns true if its argument is an array, false otherwise. */


Array.prototype.sameStructureAs = function (other) {
    if (!Array.isArray(other) || this.length != other.length)
      return false;

    for(var i = 0; i < this.length; ++i) {
      if (Array.isArray(this[i])) {
        if (!this[i].sameStructureAs(other[i])) {
          return false;
        }
      } else if (Array.isArray(other[i])) {
        return false;
      }
    }

    return true;
  };
  //https://www.codewars.com/kata/520446778469526ec0000001/train/javascript/611116670f4d7d001a67319d

  /**At a job interview, you are challenged to write an algorithm to check if a given string, s, can be formed from two other strings, part1 and part2.

The restriction is that the characters in part1 and part2 should be in the same order as in s.

The interviewer gives you the following example and tells you to figure out the rest from the given test cases.

For example:

'codewars' is a merge from 'cdw' and 'oears':

    s:  c o d e w a r s   = codewars
part1:  c   d   w         = cdw
part2:    o   e   a r s   = oears */
function isMerge(s, part1, part2) {
    return !s ? !(part1 || part2) :
      s[0] == part1[0] && isMerge(s.slice(1), part1.slice(1), part2) ||
      s[0] == part2[0] && isMerge(s.slice(1), part1, part2.slice(1));
  }
  //https://www.codewars.com/kata/54c9fcad28ec4c6e680011aa/train/javascript/611116281b30cb00491fba3d

  /**A friend of mine takes the sequence of all numbers from 1 to n (where n > 0).
Within that sequence, he chooses two numbers, a and b.
He says that the product of a and b should be equal to the sum of all numbers in the sequence, excluding a and b.
Given a number n, could you tell me the numbers he excluded from the sequence?
The function takes the parameter: n (n is always strictly greater than 0) and returns an array or a string (depending on the language) of the form:

[(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or or [{a, b}, ...]
with all (a, b) which are the possible removed numbers in the sequence 1 to n.

[(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or ... will be sorted in increasing order of the "a".

It happens that there are several possible (a, b). The function returns an empty array (or an empty string) if no possible numbers are found which will prove that my friend has not told the truth! (Go: in this case return nil).

Examples:
removNb(26) should return [(15, 21), (21, 15)]
or
removNb(26) should return { {15, 21}, {21, 15} }
or
removeNb(26) should return [[15, 21], [21, 15]]
or
removNb(26) should return [ {15, 21}, {21, 15} ]
or
removNb(26) should return "15 21, 21 15"
or

in C:
removNb(26) should return  {{15, 21}{21, 15}} tested by way of strings.
Function removNb should return a pointer to an allocated array of Pair pointers, each one also allocated. 
Note
See examples of returns for each language in "RUN SAMPLE TESTS" */

function removeNb (n) {
    var results = [];
    for (var a = 1; a <= n; a++) {
      var b = (n * (n + 1) / 2 - a) / (a + 1);
      if (b % 1 === 0 && b <= n) results.push([a, b]);
    }
    return results;
  }
  //https://www.codewars.com/kata/5547cc7dcad755e480000004/train/javascript/611115dcbc98940056ea5382

  /**In this example you have to validate if a user input string is alphanumeric. The given string is not nil/null/NULL/None, so you don't have to check that.

The string has the following conditions to be alphanumeric:

At least one character ("" is not valid)
Allowed characters are uppercase / lowercase latin letters and digits from 0 to 9
No whitespaces / underscore
 */
function alphanumeric(string){
    return /[a-zA-Z0-9]/g.test(string)&&!/[\s_!]/.test(string)
  }
  //https://www.codewars.com/kata/526dbd6c8c0eb53254000110/train/javascript/6111159f1b30cb00491fa99b



  /**Complete the function scramble(str1, str2) that returns true if a portion of str1 characters can be rearranged to match str2, otherwise returns false.

Notes:

Only lower case letters will be used (a-z). No punctuation or digits will be included.
Performance needs to be considered
Input strings s1 and s2 are null terminated.
Examples
scramble('rkqodlw', 'world') ==> True
scramble('cedewaraaossoqqyt', 'codewars') ==> True
scramble('katas', 'steak') ==> False */
function scramble(str1, str2) {
    let occurences = str1.split("").reduce((arr, cur) => { arr[cur] ? arr[cur]++ : arr[cur] = 1; return arr; }, {});
    return str2.split("").every((character) => --occurences[character] >= 0);
  }
  //https://www.codewars.com/kata/55c04b4cc56a697bb0000048/train/javascript/6111123506abc7003e7c8132

  /**In this kata, you will write a function that returns the positions and the values of the "peaks" (or local maxima) of a numeric array.

For example, the array arr = [0, 1, 2, 5, 1, 0] has a peak at position 3 with a value of 5 (since arr[3] equals 5).

The output will be returned as an object with two properties: pos and peaks. Both of these properties should be arrays. If there is no peak in the given array, then the output should be {pos: [], peaks: []}.

Example: pickPeaks([3, 2, 3, 6, 4, 1, 2, 3, 2, 1, 2, 3]) should return {pos: [3, 7], peaks: [6, 3]} (or equivalent in other languages)

All input arrays will be valid integer arrays (although it could still be empty), so you won't need to validate the input.

The first and last elements of the array will not be considered as peaks (in the context of a mathematical function, we don't know what is after and before and therefore, we don't know if it is a peak or not).

Also, beware of plateaus !!! [1, 2, 2, 2, 1] has a peak while [1, 2, 2, 2, 3] and [1, 2, 2, 2, 2] do not. In case of a plateau-peak, please only return the position and value of the beginning of the plateau. For example: pickPeaks([1, 2, 2, 2, 1]) returns {pos: [1], peaks: [2]} (or equivalent in other languages) */

function pickPeaks(arr){
    let result = { pos: [], peaks: [] };
    for (let i = 1; i < arr.length; i++) {
      var position;
      if (arr[i] > arr[i - 1]){
        position = i;
      } else if (arr[i] < arr[i - 1] && position){
        result.pos.push(position);
        result.peaks.push(arr[position]);
        position = undefined;
      }
    }
    return result;
  }
  //https://www.codewars.com/kata/5279f6fe5ab7f447890006a7/train/javascript/611111eabc98940026e9e9cb


  /**Linked Lists - Alternating Split

Write an AlternatingSplit() function that takes one list and divides up its nodes to make two smaller lists. The sublists should be made from alternating elements in the original list. So if the original list is a -> b -> a -> b -> a -> null then one sublist should be a -> a -> a -> null and the other should be b -> b -> null.

###JavaScript

var list = 1 -> 2 -> 3 -> 4 -> 5 -> null
alternatingSplit(list).first === 1 -> 3 -> 5 -> null
alternatingSplit(list).second === 2 -> 4 -> null
###Python

list = 1 -> 2 -> 3 -> 4 -> 5 -> None
alternating_split(list).first == 1 -> 3 -> 5 -> None
alternating_split(list).second == 2 -> 4 -> None
###Ruby

list = 1 -> 2 -> 3 -> 4 -> 5 -> nil
alternating_split(list).first == 1 -> 3 -> 5 -> nil
alternating_split(list).second == 2 -> 4 -> nil
For simplicity, we use a Context object to store and return the state of the two linked lists. A Context object containing the two mutated lists should be returned by AlternatingSplit().

If the passed in head node is null/None/nil or a single node, throw an error. */

function Node(data) {
    this.data = data;
    this.next = null;
  }
  
  function Context(first, second) {
    this.first = first;
    this.second = second;
  }
  
  function alternatingSplit(head) {
    if (!head || !head.next) throw new Error('invalid arguments')
    return new Context(split(head), split(head.next))
  }
  
  function split(head) {
    const list = new Node(head.data)
    if (head.next && head.next.next) list.next = split(head.next.next)
    return list
  }
  //https://www.codewars.com/kata/55dd5386575839a74f0000a9/train/javascript/611110c6511be60007d90dc5


  /** An Arithmetic Progression is defined as one in which there is a constant difference between the consecutive terms of a given series of numbers. You are provided with consecutive elements of an Arithmetic Progression. There is however one hitch: exactly one term from the original series is missing from the set of numbers which have been given to you. The rest of the given series is the same as the original AP. Find the missing term.

You have to write a function that receives a list, list size will always be at least 3 numbers. The missing term will never be the first or last one.

Example
findMissing([1, 3, 5, 9, 11]) == 7
PS: This is a sample question of the facebook engineer challenge on interviewstreet. I found it quite fun to solve on paper using math, derive the algo that way. Have fun!*/
var findMissing = function (list) {  
    var arr = (list[list.length - 1] - list[0]) / (list.length);
    return list.filter(function(val, index){ return val !== (list[0] + index * arr); }) [0] - arr ;
  }
  //https://www.codewars.com/kata/52de553ebb55d1fca3000371/train/javascript/6106dc20c8673d001a57c652

  /**The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:

maxSequence([-2, 1, -3, 4, -1, 2, 1, -5, 4])
// should be 6: [4, -1, 2, 1]
Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.

Empty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist/subarray. */

var maxSequence = function(arr){
    if(arr.every(n => n < 0)) return 0;
    let max = -Infinity;
    
    for(let i =0; i<arr.length;i++){
      for(let j=i; j<arr.length;j++){
        const subArr = arr.slice(i ,j + 1);
        const subArrTotal = subArr.reduce((acc, num) => acc + num, 0);
        
        if(subArrTotal > max){
          max = subArrTotal;
        }
      }
    }
    return max;
  }
  //https://www.codewars.com/kata/54521e9ec8e60bc4de000d6c/train/javascript/6111086f1b30cb001b1fa272


  /**Complete the solution so that the function will break up camel casing, using a space between words.

Example
"camelCasing"  =>  "camel Casing"
"identifier"   =>  "identifier"
""             =>  "" */
// complete the function
function solution(string) {
    return string.replace(/([A-Z])/g, ' $1');    
  }
//https://www.codewars.com/kata/5208f99aee097e6552000148/train/javascript/611105055896bd0007e31b2c

/**The objective is to return all pairs of integers from a given array of integers that have a difference of 2.

The result array should be sorted in ascending order of values.

Assume there are no duplicate integers in the array. The order of the integers in the input array should not matter.

Examples
[1, 2, 3, 4]  should return [[1, 3], [2, 4]]

[4, 1, 2, 3]  should also return [[1, 3], [2, 4]]

[1, 23, 3, 4, 7] should return [[1, 3]]

[4, 3, 1, 5, 6] should return [[1, 3], [3, 5], [4, 6]] */
function twosDifference(input){
    const final = [];
      for(let i=0; i < input.length;i++){
         for(let j= i+1; j < input.length;j++){
          const num1 = input[i];
          const num2 = input[j];
        
        if(Math.abs(num1 - num2) === 2){
          final.push([Math.min(num1, num2), Math.max(num1, num2)]);
        }
      }
    }
       return final.sort((a, b) => a[0] - b[0]);
    }
    
//https://www.codewars.com/kata/5340298112fa30e786000688/train/javascript/6110fd9baba0c3003b46ac99

/**A child is playing with a ball on the nth floor of a tall building. The height of this floor, h, is known.

He drops the ball out of the window. The ball bounces (for example), to two-thirds of its height (a bounce of 0.66).

His mother looks out of a window 1.5 meters from the ground.

How many times will the mother see the ball pass in front of her window (including when it's falling and bouncing?

Three conditions must be met for a valid experiment:
Float parameter "h" in meters must be greater than 0
Float parameter "bounce" must be greater than 0 and less than 1
Float parameter "window" must be less than h.
If all three conditions above are fulfilled, return a positive integer, otherwise return -1.

Note:
The ball can only be seen if the height of the rebounding ball is strictly greater than the window parameter.

Examples:
- h = 3, bounce = 0.66, window = 1.5, result is 3

- h = 3, bounce = 1, window = 1.5, result is -1 

(Condition 2) not fulfilled). */

function bouncingBall(h,  bounce,  window) {
    if(h > 0 && bounce > 0 && bounce < 1 && window < h){
      let count = 1;
      
    
    while(h > window){
      h *= bounce;
       count += 2;
      }
     return count -2;
      }
    return  -1;
   }
  
//https://www.codewars.com/kata/5544c7a5cb454edb3c000047/train/javascript/610d8da83c1d9d0032f69b40

/**Write a function that when given a URL as a string, parses out just the domain name and returns it as a string. For example:

domainName("http://github.com/carbonfive/raygun") == "github" 
domainName("http://www.zombie-bites.com") == "zombie-bites"
domainName("https://www.cnet.com") == "cnet" */

function domainName(url){
    return url.replace(/https*:\/\/|www\./g, '').split('.')[0];
  }
  //https://www.codewars.com/kata/514a024011ea4fb54200004b/train/javascript/610d870ec1b2a6003b2de711

  /**Write a function cakes(), which takes the recipe (object) and the available ingredients (also an object) and returns the maximum number of cakes Pete can bake (integer). For simplicity there are no units for the amounts (e.g. 1 lb of flour or 200 g of sugar are simply 1 or 200). Ingredients that are not present in the objects, can be considered as 0.

Examples:

// must return 2
cakes({flour: 500, sugar: 200, eggs: 1}, {flour: 1200, sugar: 1200, eggs: 5, milk: 200}); 
// must return 0
cakes({apples: 3, flour: 300, sugar: 150, milk: 100, oil: 100}, {sugar: 500, flour: 2000, milk: 2000});  */

function cakes(recipe, available) {
    let min = Infinity;
    
    Object.keys(recipe).forEach(key => {
      if(available[key] === undefined){
        available[key] = 0;
      }
     const totalCakes = Math.floor(available[key] / recipe[key]);
      if(totalCakes < min){
        min = totalCakes;
      }
    })
    
   
    return min;
    
  }
  //https://www.codewars.com/kata/525c65e51bf619685c000059/train/javascript/610acdec17b63400337196fa

  /**Create a moreZeros function which will receive a string for input, and return an array (or null terminated string in C) containing only the characters from that string whose binary representation of its ASCII value consists of more zeros than ones.

You should remove any duplicate characters, keeping the first occurence of any such duplicates, so they are in the same order in the final array as they first appeared in the input string.

Examples

'abcde' === ["1100001", "1100010", "1100011", "1100100", "1100101"]
               True       True       False      True       False
                   
        --> ['a','b','d']
    
'DIGEST'--> ['D','I','E','T']
All input will be valid strings of length > 0. Leading zeros in binary should not be counted. */

function moreZeros(s){
    return s.split('')
    .filter(removeDoubles)
    .map(convertToAscii)
    .map(convertToBinary)
    .filter(areMoreZeros)
    .map(convertToDecimal)
    .map(convertToChar) 
  
  }
  
  function removeDoubles(item, idx, arr) {
    return arr.indexOf(item) === idx;  
  }
  function convertToAscii(c){
    return c.charCodeAt(0);
  }
  function convertToBinary(num){
    return num.toString(2);
  }
  function areMoreZeros(str){
    const zeros = str.replace(/1/g, '').length;
    const ones = str.replace(/0/g, '').length;
    return zeros > ones;
  }
  function convertToDecimal(bi){
    return parseInt(bi, 2);
  }
  function convertToChar(num){
   return String.fromCharCode(num);
    }
    //https://www.codewars.com/kata/5d41e16d8bad42002208fe1a/train/javascript/610ace65bd3e450010308691
    
    /**Your task is to sum the differences between consecutive pairs in the array in descending order.

For example:

sumOfDifferences([2, 1, 10])
Returns 9

Descending order: [10, 2, 1]

Sum: (10 - 2) + (2 - 1) = 8 + 1 = 9

If the array is empty or the array has only one element the result should be 0 (Nothing in Haskell). */

function sumOfDifferences(arr) {
  
    let rezultat = 0;
    arr.sort((a,b)=> b-a);
    
    for(let i = 0; i < arr.length - 1; i++){
      
     rezultat = rezultat + (arr[i] - arr[i+1]);  
      
    }
   
    return rezultat;
  }
  //https://www.codewars.com/kata/5b73fe9fb3d9776fbf00009e/train/javascript/60f0514dc3173900251c099e

  /**Write a function toWeirdCase (weirdcase in Ruby) that accepts a string, and returns the same string with all even indexed characters in each word upper cased, and all odd indexed characters in each word lower cased. The indexing just explained is zero based, so the zero-ith index is even, therefore that character should be upper cased.

The passed in string will only consist of alphabetical characters and spaces(' '). Spaces will only be present if there are multiple words. Words will be separated by a single space(' ').

Examples:
toWeirdCase( "String" );//=> returns "StRiNg"
toWeirdCase( "Weird string case" );//=> returns "WeIrD StRiNg CaSe" */

function toWeirdCase(string){
    return string.split(' ').map(words => words.split('').map(mapToWeird).join('')).join(' ');
  }
  function mapToWeird(l ,i){
    return(i %  2 == 0) ? l.toUpperCase() : l.toLowerCase();
  }
  //https://www.codewars.com/kata/52b757663a95b11b3d00062d/train/javascript/610ac329eae55d0009eafa17

  /**A pangram is a sentence that contains every single letter of the alphabet at least once. For example, the sentence "The quick brown fox jumps over the lazy dog" is a pangram, because it uses the letters A-Z at least once (case is irrelevant).

Given a string, detect whether or not it is a pangram. Return True if it is, False if not. Ignore numbers and punctuation. */

const letters = {}

function isPangram(string){

  for(let i =97; i<= 122; i++){
    letters[String.fromCharCode(i)]= 0;
  }
  string.replace(/[^a-z]/gi, '')
  .split('')
  .forEach(l =>{
    l = l.toLowerCase();
    if(letters !== undefined){
      letters[l] ++ ;// = letters + 1; 
    }
  });
  return Object.keys(letters).every(key => letters[key] > 0);
}
//https://www.codewars.com/kata/545cedaa9943f7fe7b000048/train/javascript/610ab4ae17b634001b7131fa



/**You probably know the "like" system from Facebook and other pages. People can "like" blog posts, pictures or other items. We want to create the text that should be displayed next to such an item.

Implement the function likes which takes an array containing the names of people that like an item. It must return the display text as shown in the examples:

likes [] -- must be "no one likes this"
likes ["Peter"] -- must be "Peter likes this"
likes ["Jacob", "Alex"] -- must be "Jacob and Alex like this"
likes ["Max", "John", "Mark"] -- must be "Max, John and Mark like this"
likes ["Alex", "Jacob", "Mark", "Max"] -- must be "Alex, Jacob and 2 others like this" */

function likes(names) {
  

    if (names.length === 0) {
    return  'no one likes this';
  } else if (names.length === 1) {
    return `${names[0]} likes this`;
  } else if (names.length === 2) {
    return `${names[0]} and ${names[1]} like this`;
  } else if (names.length === 3) {
    return `${names[0]}, ${names[1]} and ${names[2]} like this`;
  } else if (names.length >= 4) {
    return `${names[0]}, ${names[1]} and ${names.length - 2} others like this`;
  }
  
    return names.slice('').join('');
  }
   
//https://www.codewars.com/kata/5266876b8f4bf2da9b000362/train/javascript/610a8cb8eae55d0009e3150f

/**#Find the missing letter

Write a method that takes an array of consecutive (increasing) letters as input and that returns the missing letter in the array.

You will always get an valid array. And it will be always exactly one letter be missing. The length of the array will always be at least 2.
The array will always contain letters in only one case.

Example:

['a','b','c','d','f'] -> 'e' ['O','Q','R','S'] -> 'P'

["a","b","c","d","f"] -> "e"
["O","Q","R","S"] -> "P"
(Use the English alphabet with 26 letters!)

Have fun coding it and please don't forget to vote and rank this kata! :-)

I have also created other katas. Take a look if you enjoyed this kata! */

function findMissingLetter(arr)
{
  for(let i = 0; i < arr.length -1; i++){
    const curr = arr[i].charCodeAt(0);
    const next = arr[i + 1].charCodeAt(0);
     
     if(curr + 1 !== next){
       return String.fromCharCode(curr + 1)
     }
    
  }
 
}
//https://www.codewars.com/kata/5839edaa6754d6fec10000a2/train/javascript/610985469b0c0a004a833d62


/**A Narcissistic Number is a positive number which is the sum of its own digits, each raised to the power of the number of digits in a given base. In this Kata, we will restrict ourselves to decimal (base 10).

For example, take 153 (3 digits), which is narcisstic:

    1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153
and 1652 (4 digits), which isn't:

    1^4 + 6^4 + 5^4 + 2^4 = 1 + 1296 + 625 + 16 = 1938
The Challenge:

Your code must return true or false depending upon whether the given number is a Narcissistic number in base 10.

Error checking for text strings or other invalid inputs is not required, only valid positive non-zero integers will be passed into the function. */

function narcissistic(value) {

    const valStr = `${value}`;
    const len = valStr.length;
    return valStr.split("").map(Number).reduce((acc, item) => acc += Math.pow(item, len), 0) === value;
  
  }
//https://www.codewars.com/kata/5287e858c6b5a9678200083c/train/javascript/6109792cbd3e45000c0b29bc  

/**Write a function that takes in a string of one or more words, and returns the same string, but with all five or more letter words reversed (like the name of this kata).

Strings passed in will consist of only letters and spaces.
Spaces will be included only when more than one word is present.
Examples:

spinWords("Hey fellow warriors") => "Hey wollef sroirraw" 
spinWords("This is a test") => "This is a test" 
spinWords("This is another test") => "This is rehtona test" */

function spinWords(longStr){

    return longStr.split(' ').map(word => (word.length >= 5) ? reverseStr (word) : word).join(' ');
  
  }
  
  function reverseStr(str){
    return str.split('').reverse().join('');
  }

  //https://www.codewars.com/kata/5264d2b162488dc400000001/train/javascript/610971993c76bb000ec0d71c

  /**Given a lowercase string that has alphabetic characters only and no spaces, return the highest value of consonant substrings. Consonants are any letters of the alphabet except "aeiou".

We shall assign the following values: a = 1, b = 2, c = 3, .... z = 26.

For example, for the word "zodiacs", let's cross out the vowels. We get: "z o d ia cs"

-- The consonant substrings are: "z", "d" and "cs" and the values are z = 26, d = 4 and cs = 3 + 19 = 22. The highest is 26.
solve("zodiacs") = 26

For the word "strength", solve("strength") = 57
-- The consonant substrings are: "str" and "ngth" with values "str" = 19 + 20 + 18 = 57 and "ngth" = 14 + 7 + 20 + 8 = 49. The highest is 57.
For C: do not mutate input.

More examples in test cases. Good luck!

If you like this Kata, please try: */

function solve(s) {
    return Math.max(...s.replace(/[aeiou]+/g,' ').trim().split(' ').map(addUpSubstring));
    };
   function charToValue(c){
     return c.charCodeAt(0) - 96;
   }
  function addUpSubstring(str){
    return str.split('').map(charToValue).reduce((acc,item) => acc += item, 0)
  }
  //https://www.codewars.com/kata/59c633e7dcc4053512000073/train/javascript/6109611e17571600225e52e0

  /**Write a function called sumIntervals/sum_intervals() that accepts an array of intervals, and returns the sum of all the interval lengths. Overlapping intervals should only be counted once.

Intervals
Intervals are represented by a pair of integers in the form of an array. The first value of the interval will always be less than the second value. Interval example: [1, 5] is an interval from 1 to 5. The length of this interval is 4.

Overlapping Intervals
List containing overlapping intervals:

[
   [1,4],
   [7, 10],
   [3, 5]
]
The sum of the lengths of these intervals is 7. Since [1, 4] and [3, 5] overlap, we can treat the interval as [1, 5], which has a length of 4.

Examples:
sumIntervals( [
   [1,2],
   [6, 10],
   [11, 15]
] ); // => 9

sumIntervals( [
   [1,4],
   [7, 10],
   [3, 5]
] ); // => 7

sumIntervals( [
   [1,5],
   [10, 20],
   [1, 6],
   [16, 19],
   [5, 11]
] ); // => 19 */
function sumIntervals(intervals){
    let numbers = [];
      
      intervals.forEach(function(interval){
        for(var i = interval[0]; i < interval[1]; i++){
          if(numbers.indexOf(i) == -1) numbers.push(i);
          
        }
      });
      return numbers.length;
    }
    //https://www.codewars.com/kata/52b7ed099cdc285c300001cd/train/javascript/6106e2403e38e9000ec81543

    /**Assume "#" is like a backspace in string. This means that string "a#bc#d" actually is "bd"

Your task is to process a string with "#" symbols.

Examples
"abc#d##c"      ==>  "ac"
"abc##d######"  ==>  ""
"#######"       ==>  ""
""              ==>  "" */

function cleanString(s) {
    let result = [];
      
      for(let i =0 ; i< s.length;i++){
        const char = s[i];
        if(char === "#"){
          result.pop();
        } else {
          result.push(char);
        }
      }
      return result.join("");
    };
    //https://www.codewars.com/kata/5727bb0fe81185ae62000ae3/train/javascript/6106dfe9eeaf3c004a42bd18

    /**It's a Pokemon battle! Your task is to calculate the damage that a particular move would do using the following formula (not the actual one from the game):

damage = 50 * (attack / defense) * effectiveness
Where:

attack = your attack power
defense = the opponent's defense
effectiveness = the effectiveness of the attack based on the matchup (see explanation below)
Effectiveness:

Attacks can be super effective, neutral, or not very effective depending on the matchup. For example, water would be super effective against fire, but not very effective against grass.

Super effective: 2x damage
Neutral: 1x damage
Not very effective: 0.5x damage
To prevent this kata from being tedious, you'll only be dealing with four types: fire, water, grass, and electric. Here is the effectiveness of each matchup:

fire > grass
fire < water
fire = electric
water < grass
water < electric
grass = electric
For this kata, any type against itself is not very effective. Also, assume that the relationships between different types are symmetric (if A is super effective against B, then B is not very effective against A).

The function you must implement takes in:

1.your type
2.the opponent's type
3.your attack power
4.the opponent's defense */
function calculateDamage(yourType, opponentType, attack, defense){
    let effectiveness = 1;
    if(yourType === 'fire' &&  opponentType === 'grass'){
      effectiveness = 2;
    }
    else if(yourType === 'fire' &&  opponentType === 'water'){
      effectiveness = 0.5;
    }
    else if(yourType === 'water' &&  opponentType === 'fire'){
      effectiveness = 2;
    }
    else if(yourType === 'water' &&  opponentType === 'grass'){
      effectiveness = 0.5;
    }
    else if(yourType === 'water' &&  opponentType === 'electric'){
      effectiveness = 0.5;
    }
    else if(yourType === 'grass' &&  opponentType === 'water'){
      effectiveness = 2;
    }
    else if(yourType === 'grass' &&  opponentType === 'fire'){
      effectiveness = 0.5;
    }
    else if(yourType === 'electric' &&  opponentType === 'water'){
      effectiveness = 2;
    }
    else if(yourType === opponentType){
      effectiveness = 0.5;
    }
    return 50 * (attack / defense) * effectiveness;
}
//https://www.codewars.com/kata/536e9a7973130a06eb000e9f/train/javascript/6106dd32bcc1ea003e4bace5

/**Given an array of ones and zeroes, convert the equivalent binary value to an integer.

Eg: [0, 0, 0, 1] is treated as 0001 which is the binary representation of 1.

Examples:

Testing: [0, 0, 0, 1] ==> 1
Testing: [0, 0, 1, 0] ==> 2
Testing: [0, 1, 0, 1] ==> 5
Testing: [1, 0, 0, 1] ==> 9
Testing: [0, 0, 1, 0] ==> 2
Testing: [0, 1, 1, 0] ==> 6
Testing: [1, 1, 1, 1] ==> 15
Testing: [1, 0, 1, 1] ==> 11
However, the arrays can have varying lengths, not just limited to 4. */
const binaryArrayToNumber = arr => {
    return parseInt(arr.join(''), 2);
  };


//https://www.codewars.com/kata/578553c3a1b8d5c40300037c/train/javascript/6106db8ebcc1ea0021498c52


  /**Write a simple parser that will parse and run Deadfish.

Deadfish has 4 commands, each 1 character long:

i increments the value (initially 0)
d decrements the value
s squares the value
o outputs the value into the return array
Invalid characters should be ignored.

parse("iiisdoso") => [ 8, 64 ] */
const actions = {
    i: (x) => x+1,
    d: (x) => x-1,
    s: (x) => x*x
  }
  function parse( data )
  {
    let num = 0;
    let arr = [];
    
    data.split('').forEach(action => {
      if(actions[action]){
        num = actions[action](num);
        
      } else if (action === 'o'){
        arr.push(num);
      }
    });
     return arr
  }

  //https://www.codewars.com/kata/51e0007c1f9378fa810002a9/train/javascript/6106ccb03e38e90015c69889


  /**The rgb function is incomplete. Complete it so that passing in RGB decimal values will result in a hexadecimal representation being returned. Valid decimal values for RGB are 0 - 255. Any values that fall out of that range must be rounded to the closest valid value.

Note: Your answer should always be 6 characters long, the shorthand with 3 will not work here.

The following are examples of expected output values:

rgb(255, 255, 255) // returns FFFFFF
rgb(255, 255, 300) // returns FFFFFF
rgb(0,0,0) // returns 000000
rgb(148, 0, 211) // returns 9400D3 */

function rgb(r, g, b) {
    const convert = function(val) {
      if(val < 0) {
        return '00';
      }
      if(val > 255) {
        return 'FF';
      }
      return (val > 15 ? val.toString(16) : '0' + val.toString(16)).toUpperCase();
    }
    return convert(r) + convert(g) + convert(b); 
  }
  //https://www.codewars.com/kata/513e08acc600c94f01000001/train/javascript/6106c3bd3e38e90007c57e61

  /**Acknowledgments:
I thank yvonne-liu for the idea and for the example tests :)

Description:
Encrypt this!

You want to create secret messages which can be deciphered by the Decipher this! kata. Here are the conditions:

Your message is a string containing space separated words.
You need to encrypt each word in the message using the following rules:
The first letter needs to be converted to its ASCII code.
The second letter needs to be switched with the last letter
Keepin' it simple: There are no special characters in input.
Examples:
encryptThis("Hello") === "72olle"
encryptThis("good") === "103doo"
encryptThis("hello world") === "104olle 119drlo" */

function encryptThis(text) {
    let strArr = text.split(' ');
    let output = [];
    
    strArr.forEach(str => {
      if (str.length === 1) {
        output.push(str.charCodeAt(0));
      } 
      else {
        let tempStr = str.split('');
        tempStr[0] = str.charCodeAt(0);
        tempStr[1] = str[str.length - 1];
        tempStr[str.length - 1] = str[1];
        output.push(tempStr.join(''));
      }
    });
    
    return output.join(' ');
  }
  //https://www.codewars.com/kata/5848565e273af816fb000449/train/javascript/6106a79092c393005252c2fb


  /**Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob — to check his answers, he needs a program that among the given numbers finds one that is different in evenness, and return a position of this number.

! Keep in mind that your task is to help Bob solve a real IQ test, which means indexes of the elements start from 1 (not 0)

Examples:
iqTest("2 4 7 8 10") => 3 // Third number is odd, while the rest of the numbers are even

iqTest("1 2 1 1") => 2 // Second number is even, while the rest of the numbers are odd */

function iqTest(numbers){
    numbers = numbers.split(" ").map(function(num){return parseInt(num)});
    
    let odd = numbers.filter(function(num){ return num % 2 === 1});
    let even = numbers.filter(function(num){ return num % 2 === 0});
    
    return odd.length < even.length ? (numbers.indexOf(odd[0]) + 1) : (numbers.indexOf(even[0]) + 1);
  }
  //https://www.codewars.com/kata/552c028c030765286c00007d/train/javascript/61069b061b2757003f06f057
 
  
  /**The main idea is to count all the occurring characters in a string. If you have a string like aba, then the result should be {'a': 2, 'b': 1}.

What if the string is empty? Then the result should be empty object literal, {}. */
function count (string) {  
    const count = {}
    string.split('').forEach(s => {
      count[s] ? count[s]++ : count[s] = 1
    });
    return count
  }
  //https://www.codewars.com/kata/52efefcbcdf57161d4000091/train/javascript/6105e191b02dcb0041b41c4a

  /** You must create a method that can convert a string from any format into PascalCase. This must support symbols too.

Don't presume the separators too much or you could be surprised.

For example: (Input --> Output)

"example name" --> "ExampleName"
"your-NaMe-here" --> "YourNameHere"
"testing ABC" --> "TestingAbc"*/
function camelize(str){
    const arr = str.split(/[^0-9a-zA-Z]+/g);
    str = arr.map( x => {
    
    return x.charAt(0).toUpperCase() + x.slice(1).toLowerCase();
    }).join("");
  ;
    
    return str
    }
    //https://www.codewars.com/kata/525821ce8e7b0d240b002615/train/javascript/6105e18eb02dcb0032b47eb6

    /**Write a function that accepts an array of 10 integers (between 0 and 9), that returns a string of those numbers in the form of a phone number.

Example
createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) // => returns "(123) 456-7890"
The returned format must be correct in order to complete this challenge.
Don't forget the space after the closing parentheses! */

function createPhoneNumber(numbers){
    let format = "(xxx) xxx-xxxx";
    
    for(let i = 0; i < numbers.length; i++)
    {
      format = format.replace('x', numbers[i]);
    }
    
    return format;
  }
//https://www.codewars.com/kata/525f50e3b73515a6db000b83/train/javascript/6105df42b02dcb003db48dcf

/**Given: an array containing hashes of names

Return: a string formatted as a list of names separated by commas except for the last two names, which should be separated by an ampersand.

Example:

list([ {name: 'Bart'}, {name: 'Lisa'}, {name: 'Maggie'} ])
// returns 'Bart, Lisa & Maggie'

list([ {name: 'Bart'}, {name: 'Lisa'} ])
// returns 'Bart & Lisa'

list([ {name: 'Bart'} ])
// returns 'Bart'

list([])
// returns '' */
function list(names){
    let str = '';
    if (names.length !== 0) {
      let last = names.pop();
      str = names.map( (val, i, arr) => {
        if (i !== arr[arr.length - 1]) {
          return val.name;
        }
      }).join(', ')
       
      str += str !== '' ? ' & ' + last.name : last.name;
    }
     
    return str;
  }
  //https://www.codewars.com/kata/53368a47e38700bd8300030d/train/javascript/6105d97fb02dcb0041b326cd

  /**We'll create a function that takes in two parameters:

a sequence (length and types of items are irrelevant)
a function (value, index) that will be called on members of the sequence and their index. The function will return either true or false.
Your function will iterate through the members of the sequence in order until the provided function returns true; at which point your function will return that item's index.

If the function given returns false for all members of the sequence, your function should return -1.

var trueIfEven = function(value, index) { return (value % 2 === 0) };
findInArray([1,3,5,6,7], trueIfEven) // should === 3 */


var findInArray = function(array, iterator) {
    let result = [];
    for(let i = 0; i < array.length; i ++){
    
      if(iterator(array[i], i))
        {
          return i;
        }
    }
    return -1;
    
  };
  //https://www.codewars.com/kata/51f082ba7297b8f07f000001/train/javascript/6102baa1c135de000d23a569

  /**John has invited some friends. His list is:

s = "Fred:Corwill;Wilfred:Corwill;Barney:Tornbull;Betty:Tornbull;Bjon:Tornbull;Raphael:Corwill;Alfred:Corwill";
Could you make a program that

makes this string uppercase
gives it sorted in alphabetical order by last name.
When the last names are the same, sort them by first name. Last name and first name of a guest come in the result between parentheses separated by a comma.

So the result of function meeting(s) will be:

"(CORWILL, ALFRED)(CORWILL, FRED)(CORWILL, RAPHAEL)(CORWILL, WILFRED)(TORNBULL, BARNEY)(TORNBULL, BETTY)(TORNBULL, BJON)"
It can happen that in two distinct families with the same family name two people have the same first name too.

Notes
You can see another examples in the "Sample tests". */
function meeting(s) {

    let upper = s.toUpperCase();
    upper = upper.split(';');
  
    
    for(let i = 0; i < upper.length; i++){
     upper[i]= upper[i].split(':').reverse();
     }
    return upper.sort().reduce((acc, name)=> {
      return acc +=`(${name[0]}, ${name[1]})`
    },"")
    
    }
    //https://www.codewars.com/kata/59df2f8f08c6cec835000012/train/javascript/61028d5ff3fdeb003dc973bb

    /**In a small restaurant there are A tables for one person and B tables for two persons.

It it known that N groups of people come today, each consisting of one or two people.

If a group consist of one person, it is seated at a vacant one-seater table. If there are none of them, it is seated at a vacant two-seater table. If there are none of them, it is seated at a two-seater table occupied by single person. If there are still none of them, the restaurant denies service to this group.

If a group consist of two people, it is seated at a vacant two-seater table. If there are none of them, the restaurant denies service to this group.

You are given a chronological order of groups coming. You are to determine the total number of people the restaurant denies service to.

Input:
Input contains two integers A and B - the number of one-seater and the number of two-seater tables respectively, and a list of integers - the number of people in each group of clients in chronological order of their arrival.

Output:
Return the total number of people the restaurant denies service to.

Examples:
(1, 2, [1, 2, 1, 1])  =>  0
(1, 1, [1, 1, 2, 1])  =>  2
In the first example the first group consists of one person, it is seated at a vacant one-seater table. The next group occupies a whole two-seater table. The third group consists of one person, it occupies one place at the remaining two-seater table. The fourth group consists of one person, he is seated at the remaining seat at the two-seater table. Thus, all clients are served.

In the second example the first group consists of one person, it is seated at the vacant one-seater table. The next group consists of one person, it occupies one place at the two-seater table. It's impossible to seat the next group of two people, so the restaurant denies service to them. The fourth group consists of one person, he is seated at the remaining seat at the two-seater table. Thus, the restaurant denies service to 2 clients.

(c)KAN */
function restaurant(a,b,t){
    let total = 0;
    let c = 0;
    
    for(let i = 0; i < t.length; i++){
      if(t[i] == 1){
        
        if(a > 0){
         a = a - 1;
        } 
      else if(b > 0){
          b = b - 1;
          c = c + 1;
        }
        else if (c > 0){
          c = c - 1;
        }
         else {
           total = total + 1;
         }
      }
        
     else if(t[i] == 2){
       
         if(b > 0){
          b = b - 1;
         
       }
       else {
         total = total + 2;
         }
      }  
      
    }
    return total;
  }
  //https://www.codewars.com/kata/598c1bc6a04cd3b8dd000012/train/javascript/610272f1f3fdeb0025c6b679

  /**Write a function that returns the greatest common factor of an array of positive integers. Your return value should be a number, you will only receive positive integers.

greatestCommonFactor([46, 14, 20, 88]); // --> 2 */


function greatestCommonFactor(array) {
    function gcf(a, b) {
      if (b === 0) return a;
      return gcf(b, a % b);
  
    }
    return array.reduce(gcf);
  };
  //https://www.codewars.com/kata/5849169a6512c5964000016e/train/javascript/61013f7c9347db0019c831b2

  /**You are given two arrays a1 and a2 of strings. Each string is composed with letters from a to z. Let x be any string in the first array and y be any string in the second array.

Find max(abs(length(x) − length(y)))

If a1 and/or a2 are empty return -1 in each language except in Haskell (F#) where you will return Nothing (None).

Example:
a1 = ["hoqq", "bbllkw", "oox", "ejjuyyy", "plmiis", "xxxzgpsssa", "xxwwkktt", "znnnnfqknaz", "qqquuhii", "dvvvwz"]
a2 = ["cccooommaaqqoxii", "gggqaffhhh", "tttoowwwmmww"]
mxdiflg(a1, a2) --> 13
Bash note:
input : 2 strings with substrings separated by ,
output: number as a string */
function mxdiflg(a1, a2) {
    if(!a1.length || !a2.length){
      return -1;
    }
  let arr = [];
  
  for(let i = 0; i< a1.length; i++){
    for(let j =0; j < a2.length; j++)
    
    arr.push(Math.abs(a1[i].length - a2[j].length));
    
  }
  return Math.max.apply(Math, arr);
  
}
//https://www.codewars.com/kata/5663f5305102699bad000056/train/javascript/6101346a3171fe002802521b

/**When no more interesting kata can be resolved, I just choose to create the new kata, to solve their own, to enjoy the process --myjinxin2015 said

Description:
You are given a number sequence(an array) that contains some positive integer and zero.

[3,2,1,0,5,6,4,0,1,5,3,0,4,2,8,0]
It can be split to some zero-terminated sub sequence, such as [3,2,1,0],[5,6,4,0]...

Your task is: First, sort each sub sequence according to the ascending order(don't sort the zero, it always at the end); Second, sort all sub sequence according to their sum value(ascending order too).

Arguments:
sequence: The number sequence.
Results & Note:
The result is the sorted number sequence.
If some sub sequences have the same sum value, sort them according to their original order.
Some Examples
sortSequence([3,2,1,0,5,6,4,0,1,5,3,0,4,2,8,0]) should return
[1,2,3,0,1,3,5,0,2,4,8,0,4,5,6,0]

sortSequence([3,2,1,0,5,6,4,0,1,5,3,0,2,2,2,0]) should return
[1,2,3,0,2,2,2,0,1,3,5,0,4,5,6,0]

sortSequence([2,2,2,0,5,6,4,0,1,5,3,0,3,2,1,0]) should return
[2,2,2,0,1,2,3,0,1,3,5,0,4,5,6,0] */

function sortSequence(sequence){
    let arr = [];
    let helper = [];
    
    
    for(let i = 0; i < sequence.length; i++){
    
      while(sequence[i] != 0){
        helper.push(sequence[i]);
        i++;
         
         }   
      arr.push(helper.sort((a,b) => a - b )); // arr ni e niza od nizi [[1,2,3,4,5,],[],...,[]]
      helper = [];
    }
     
    let nizamap = [];
    
     for(let i = 0; i < arr.length; i++){
       
       nizamap.push({
        value : arr[i],
        sum: arr[i].reduce((a,b) => a+b),
         index : i
       });
     }
    
    nizamap.sort((a,b) => a.sum - b.sum || a.index - b.index);
    
      arr = [];
   
  
    for( let i = 0;  i < nizamap.length; i++){
      
      for(let j =0; j < nizamap[i].value.length; j++){
        
        arr.push(nizamap[i].value[j]);
      }
      arr.push(0);
      
    }
  
    return arr;
    
    
    console.log(nizamap[1].sum);
    
    
  }
  //https://www.codewars.com/kata/5816b76988ca9613cc00024f/train/javascript/60fff9f09347db000da83a0e


  /**Your task in this kata is to implement a function that calculates the sum of the integers inside a string. For example, in the string "The30quick20brown10f0x1203jumps914ov3r1349the102l4zy dog", the sum of the integers is 3635. */
  
  function sumOfIntegersInString(s){
    let arr = [];
    let c = s.split("");
    let sum = 0;
    
    
    
    for(let i =0; i <c.length;i++){
      if(c[i] >= '0' && c[i] <= '9'){
        let buildNumber = "";
          while(c[i] >= '0' && c[i] <= '9' && i < c.length){
            
            buildNumber += c[i];
            i++;
          }
        arr.push(parseInt(buildNumber));
      }
      
    }
    
    for(let i = 0; i < arr.length; i++){
        sum += arr[i];
      
    }
    
    
    
    return sum;
  }
  //https://www.codewars.com/kata/598f76a44f613e0e0b000026/train/javascript/60ffcab1d80e47002824c690

  /**Write a function that takes an array of strings as an argument and returns a sorted array containing the same strings, ordered from shortest to longest.

For example, if this array were passed as an argument:

["Telescopes", "Glasses", "Eyes", "Monocles"]

Your function would return the following array:

["Eyes", "Glasses", "Monocles", "Telescopes"]

All of the strings in the array passed to your function will be different lengths, so you will not have to decide how to order multiple strings of the same length. */

function sortByLength (array) {
  
    return array.sort((a,b) => a.length - b.length);
  };
  //https://www.codewars.com/kata/57ea5b0b75ae11d1e800006c/train/javascript/60ff1f36c9a4fd003ee781a1

  /**Write a function that accepts a string, and returns true if it is in the form of a phone number.
Assume that any integer from 0-9 in any of the spots will produce a valid phone number.

Only worry about the following format:
(123) 456-7890 (don't forget the space after the close parentheses)

Examples:

"(123) 456-7890"  => true
"(1111)555 2345"  => false
"(098) 123 4567"  => false */
function validPhoneNumber(phoneNumber){
    let regex = /^\(\d{3}\) \d{3}-\d{4}$/
     return regex.test(phoneNumber);
    }
    //https://www.codewars.com/kata/525f47c79f2f25a4db000025/train/javascript/60feac86068a63000de79729

    /**Time to win the lottery!

Given a lottery ticket (ticket), represented by an array of 2-value arrays, you must find out if you've won the jackpot.

Example ticket:

[ [ 'ABC', 65 ], [ 'HGR', 74 ], [ 'BYHT', 74 ] ]
To do this, you must first count the 'mini-wins' on your ticket. Each subarray has both a string and a number within it. If the character code of any of the characters in the string matches the number, you get a mini win. Note you can only have one mini win per sub array.

Once you have counted all of your mini wins, compare that number to the other input provided (win). If your total is more than or equal to (win), return 'Winner!'. Else return 'Loser!'.

All inputs will be in the correct format. Strings on tickets are not always the same length. */

function bingo(ticket, win){
    let miniwins = 0;
    let arr = [];
    
    for(let i = 0; i < ticket.length; i++){
        arr = ticket[i]
    
    for(let j =0; j <arr[0].length; j++){
      if(arr[0].charCodeAt(j) === arr[1]){
        
        miniwins++;
        break;
      }  
    }
      }
    if(miniwins >= win){
      
      return 'Winner!'
    }
    return 'Loser!'
  }
  //https://www.codewars.com/kata/57f625992f4d53c24200070e/train/javascript/60fea8bc383e560058ce143f

  
  /**Given two arrays of strings a1 and a2 return a sorted array r in lexicographical order of the strings of a1 which are substrings of strings of a2.

Example 1:
a1 = ["arp", "live", "strong"]

a2 = ["lively", "alive", "harp", "sharp", "armstrong"]

returns ["arp", "live", "strong"]

Example 2:
a1 = ["tarp", "mice", "bull"]

a2 = ["lively", "alive", "harp", "sharp", "armstrong"]

returns []

Notes:
Arrays are written in "general" notation. See "Your Test Cases" for examples in your language.
In Shell bash a1 and a2 are strings. The return is a string where words are separated by commas.
Beware: r must be without duplicates. */
function inArray(array1,array2){
  
    var r =[];
    
    for(var i = 0; i < array1.length;i++){
      
      if(array1[i] == null) 
        continue;
      
       var reg = new RegExp(array1[i]);
      
       for(var j = 0; j < array2.length;j++){
         if(reg.exec(array2[j]) != null){
           r.push(array1[i]);
           break;
           
         }
         
       }
      
    }
    r = r.sort();
    return r;
  }
  //https://www.codewars.com/kata/550554fd08b86f84fe000a58/train/javascript/60f0597dc31739003d1c51c6

  /**Write a function that will take in any array and reverse it.

Sounds simple doesn't it?

NOTES:

Array should be reversed in place! (no need to return it)
Usual builtins have been deactivated. Don't count on them.
You'll have to do it fast enough, so think about performances
 */

function reverse(arr) {
   
    for(var i= 0; i < arr.length / 2; i++){
        const temp = arr[i];
        arr[i] =arr [arr.length - 1 - i];
        arr[arr.length - 1 - i] = temp;
  
  }
    }
    //https://www.codewars.com/kata/55de9c184bb732a87f000055/train/javascript/60f802f686c64d00494cb22f

    /**Your friend has invited you to watch a tennis match at a local sports club. Since tennis isn't your favorite sport, you get bored right at the start of the first game and start looking for something to keep yourself entertained. Noticing the scoreboard, you realize you don't even know how many points have been won since the game started, so you decided to calculate this number. Given the current score, your goal is to find the number of points won in the current game.

If you are not familiar with tennis rules, here's a short description of its scoring system. Score calling is unique in tennis: each point has a corresponding call that is different from its point value. The table of points won and corresponding calls is given below.

+----------------------+--------------------+
| Number of points won | Corresponding call |
+----------------------+--------------------+
|          0           |      "love"        |
+----------------------+--------------------+
|          1           |       "15"         |
+----------------------+--------------------+
|          2           |       "30"         |
+----------------------+--------------------+
|          3           |       "40"         |
+----------------------+--------------------+
There's an additional rule to remember: when players are tied by one or two points, the score is described as "15-all" and "30-all", respectively.

It's guaranteed that no more than 5 points have been won so far, and the game is not over yet. It is also guaranteed that at least one point has been won.

Input/Output
[input] string score

A string in the format <p1>-<p2> representing a valid score, where <p1> is the first player's score, and <p2> is the second player's score.

[output] an integer

The number of points won so far.

Example
For score = "15-40", the output should be 4.

The first player won 1 point, and the second 3, so 1 + 3 = 4 points have been won.

For score = "30-all", the output should be 4.

The players have won 2 points each. */
function tennisGamePoints(score) {
  
    // Proverka dali scorot e 15-all ako e vrati 2
    if(score == "15-all"){
      return 2;
      
    }
    
    // Proverka dali scorot e 30-all ako e vrati 4
    if(score == "30-all"){
      return 4;
    }
    
    // Zemi gi poenite na playerite i podeli gi vo niza (player1 == niza[0], player2 == niza[1])
    var arr = score.split("-");
    
    var result = 0;
  
    // Proveri go rezultatot na dvata playeri
    for(var i = 0; i < 2; i++)
      {
        if(arr[i] == "15")
          {
            result += 1;
          }
        else if(arr[i] == "30")
          {
            result += 2;
          }
        else if(arr[i] == "40")
          {
            result += 3;
          }
      }
    
    return result;
    
  }
  //https://www.codewars.com/kata/590942d4efde93886900185a/train/javascript/60f87fac776cc40055b04795
  

  /**Story
The construction of the new Death Star is almost complete. It only needs a certain amount of 3 materials – iron, steel, and chromium. The emperor wants the construction finished within a week because he senses an impending rebel attack and knows the battle station will be destroyed if it is not completed within this timeframe. He has already ordered enough material delivered to the station within a week. The problem is, the rebels are attacking the supply routes and there are different amounts of material arriving at the station each week. Will the station be ready in time or will it be destroyed?

Task
The required resources are:

100 Gt of iron
75 Gt of steel
50 Gt of chromium
The input will consist of an array with 8 elements:

The first 7 elements are the shipments - 3-elements-long arrays where each number corresponds to the amount of material that was ordered (iron, steel, and chromium)
The last element is a number representing the day of the rebel attack (0-indexed) - any materials which should have been delivered that day will be lost, and later shipments will be cancelled due to the trading route becoming unsafe
The output will be one of the two possible string:

In case enough resources were delivered before the attack, return "The station is completed!"
Otherwise, return "The station is destroyed! It needed X iron, Y steel and Z chromium for completion.", where X, Y and Z are the quantities of the respective material */
function deathStar(week) {

    var iron = 0;
    var steel = 0;
    var chromium = 0;
    
    for(var i= 0; i < week[week.length-1];i++){
      
      iron += week[i][0];
      steel += week[i][1];
      chromium += week[i][2];
      
    }
    if(iron >= 100 && steel >= 75 && chromium >= 50){
      return "The station is completed!";
    }
    var resultiron = 0;
    var resultsteel = 0;
    var resultchromium = 0;
    
    if(iron < 100){
      resultiron= 100 - iron;
    }
     if(steel < 75){
      resultsteel = 75 - steel;
    }
     if(chromium < 50){
      resultchromium = 50 - chromium;
    }
    
    return "The station is destroyed! It needed " + resultiron +" iron, "+ resultsteel+" steel and "+resultchromium+" chromium for completion.";
  }
  //https://www.codewars.com/kata/5a996f3d5084d73a7100040c/train/javascript/60f6e5fcca1ef9003118200d

  /**Finish the solution so that it takes an input n (integer) and returns a string that is the decimal representation of the number grouped by commas after every 3 digits.

Assume: 0 <= n < 2147483647

Examples
       1  ->           "1"
      10  ->          "10"
     100  ->         "100"
    1000  ->       "1,000"
   10000  ->      "10,000"
  100000  ->     "100,000"
 1000000  ->   "1,000,000"
35235235  ->  "35,235,235" */
function groupByCommas(n) {
    var s = n.toString();
    var niza = [];
    
    s = s.split('').reverse().join('');
    
    for(var i = 0; i < s.length; i+=3)
    {
      niza.push(s.substr(i,3))
    }
    
       var result = niza.join(',');
   
      return result.split('').reverse().join('');
  }
  //https://www.codewars.com/kata/5274e122fc75c0943d000148/train/javascript/60f7f22e86c64d000d4a65ce

  /**Given an array of numbers, return a string made up of four parts:

a four character 'word', made up of the characters derived from the first two and last two numbers in the array. order should be as read left to right (first, second, second last, last),

the same as above, post sorting the array into ascending order,

the same as above, post sorting the array into descending order,

the same as above, post converting the array into ASCII characters and sorting alphabetically.

The four parts should form a single string, each part separated by a hyphen (-).

Example format of solution: "asdf-tyui-ujng-wedg"

Examples
[111, 112, 113, 114, 115, 113, 114, 110]  -->  "oprn-nors-sron-nors"
[66, 101, 55, 111, 113]                   -->  "Beoq-7Boq-qoB7-7Boq"
[99, 98, 97, 96, 81, 82, 82]              -->  "cbRR-QRbc-cbRQ-QRbc" */
function sortTransform(arr) {
    const fourElementArr = (arr) => {
      return arr.slice(0, 2).concat(arr.slice(-2));
    };
  
    const str1 = fourElementArr(arr)
      .map((current) => String.fromCharCode(current))
      .join('');
    const str2 = fourElementArr(arr.sort((a, b) => a - b))
      .map((current) => String.fromCharCode(current))
      .join('');
    const str3 = fourElementArr(arr.sort((a, b) => b - a))
      .map((current) => String.fromCharCode(current))
      .join('');
    const str4 = fourElementArr(arr.map((current) => String.fromCharCode(current)).sort()).join('');
    console.log(str1, str2, str3, str4);
    return [str1, str2, str3, str4].join('-');
  }
//https://www.codewars.com/kata/57cc847e58a06b1492000264/train/javascript/60f7ec88aaa2330055ae7006


/**Given a sequence of integers, return the sum of all the integers that have an even index, multiplied by the integer at the last index.

Indices in sequence start from 0.

If the sequence is empty, you should return 0. */
function evenLast(numbers) {
  
    var sum = 0
    
    if(numbers.length == 0){
    
      return 0
      
    }
      for(var i=0;i<numbers.length;i++){
    
      if(i % 2 == 0)
        {
          sum += numbers[i]
        }
      }
    return sum * numbers[numbers.length-1]
  }
//https://www.codewars.com/kata/5a1a9e5032b8b98477000004/train/javascript/60f71967a340c70049201f4d

/**Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.

It should remove all values from list a, which are present in list b keeping their order.

arrayDiff([1,2],[1]) == [2]
If a value is present in b, all of its occurrences must be removed from the other:

arrayDiff([1,2,2,2,3],[2]) == [1,3] */
function arrayDiff(a, b) {
  
    let arr=[];
    
    if(a.length == 0){
      
      return [];
    }
    for(let i = 0; i < a.length;i++){
      if(b.indexOf(a[i]) == -1){
        
        arr.push(a[i]);
      }
    }
  
     for(let i = 0; i < b.length;i++){
      if(a.indexOf(b[i]) == -1){
        
        arr.push(b[i]);
      }
    }
    return arr;
  }
//https://www.codewars.com/kata/523f5d21c841566fde000009/train/javascript/60f6e678ca1ef9000d18135b

/**Task:
Given a list of integers, determine whether the sum of its elements is odd or even.

Give your answer as a string matching "odd" or "even".

If the input array is empty consider it as: [0] (array with a zero).

Examples:
Input: [0]
Output: "even"

Input: [0, 1, 4]
Output: "odd"

Input: [0, -1, -5]
Output: "even" */
function oddOrEven(array) {
    var sum = 0;
    
    for(var i = 0;i <array.length;i++){
      
      sum = sum + array[i];    
    }
      if(sum % 2 == 0) {
        
        return('even');
     } 
      else 
     {
       return('odd');
     }
      return array;
    }
    //https://www.codewars.com/kata/5949481f86420f59480000e7/train/javascript/60f6aa92d02629003e164bda

    /**Write a small function that returns the values of an array that are not odd.

All values in the array will be integers. Return the good values in the order they are given. */
function noOdds(arr){
    let noOddArray = [];
    
    for (let i = 0; i < arr.length; i++) {
      if(arr[i] % 2 == 0) {
        noOddArray.push(arr[i]);
      }
    }
    
    return noOddArray;
  }
  //https://www.codewars.com/kata/51fd6bc82bc150b28e0000ce/train/javascript/60f6a75186c64d00062646ff

  /**Given two arrays, a1 and a2, sort the elements of a2 based on the the index of the word in a1 that begins with the same letter.

Example 1
var a1 = ['giraffe', 'orangutan', 'impala', 'elephant', 'rhino'];
var a2 = ['rattlesnake', 'eagle', 'geko', 'iguana', 'octopus'];

returns ['geko', 'octopus', 'iguana', 'eagle', 'rattlesnake']
Example 2
var a1 = ['jellyfish', 'koi', 'caribou', 'owl', 'dolphin'];
var a2 = ['ostrich', 'jaguar', 'deer', 'camel', 'kangaroo'];

returns ['jaguar', 'kangaroo', 'camel', 'ostrich', 'deer']
Each element in the arrays will start with a unique letter so there will only be a single match for each element. */
function sortArray(a1, a2) {
    let result = [];
  
    for(let i = 0; i < a1.length; i++)
    {
      
    for(let j = 0; j < a1.length; j++)
    {
      
     if(a1[i].charAt(0) == a2[j].charAt(0))
     {
       result.push(a2[j]);
      
     }
     
    }
    
    }
     return result;
        
  }
//https://www.codewars.com/kata/57fe864854685b1c420002e0/train/javascript/60f04d0d23e2e0004395b4c4

/**In mathematics, the factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example: 5! = 5 * 4 * 3 * 2 * 1 = 120. By convention the value of 0! is 1.

Write a function to calculate factorial for a given input. If input is below 0 or above 12 throw an exception of type ArgumentOutOfRangeException (C#) or IllegalArgumentException (Java) or RangeException (PHP) or throw a RangeError (JavaScript) or ValueError (Python) or return -1 (C).

More details about factorial can be found here. */
function factorial(n){
  
    if(n < 0 || n > 12) return IllegalArgumentException;
     var rez = 1;
    
    for(var i = n;i > 0; i--){
      
      rez = rez * i;
    }
    return rez;
  }
  //https://www.codewars.com/kata/54ff0d1f355cfd20e60001fc/train/javascript/60f5d35d5e97be00077bdb73


  /**Convert number to reversed array of digits
Given a random non-negative number, you have to return the digits of this number within an array in reverse order.

Example:
348597 => [7,9,5,8,4,3] */
function digitize(n) {
 
    let arr=[];
    
    while(n != 0){
      
      let rez = n % 10;
      arr.push(rez);
      n = Math.floor (n / 10);
    }
    return arr;
  }
  //https://www.codewars.com/kata/5583090cbe83f4fd8c000051/train/javascript/60f5cce15e97be001a7b0fd1


  /**Create a function with two arguments that will return an array of the first (n) multiples of (x).

Assume both the given number and the number of times to count will be positive numbers greater than 0.

Return the results as an array (or list in Python, Haskell or Elixir).

Examples:

countBy(1,10) === [1,2,3,4,5,6,7,8,9,10]
countBy(2,5) === [2,4,6,8,10] */
function countBy(x, n) {
  
    var z = [];
   
    
    for(var i = 1;i <= n;i++){
      z.push(i*x);
    }
    
    return z;
  }
  //https://www.codewars.com/kata/5513795bd3fafb56c200049e/train/javascript/60f5c8fd5e97be001a7acf74


  /**Your goal is to return multiplication table for number that is always an integer from 1 to 10.

For example, a multiplication table (string) for number == 5 looks like below:

1 * 5 = 5
2 * 5 = 10
3 * 5 = 15
4 * 5 = 20
5 * 5 = 25
6 * 5 = 30
7 * 5 = 35
8 * 5 = 40
9 * 5 = 45
10 * 5 = 50
P. S. You can use \n in string to jump to the next line.

Note: newlines should be added between rows, but there should be no trailing newline at the end. If you're unsure about the format, look at the */
function multiTable(input) {
  
    let rezultat = "";
    
    for(let i = 1; i <= 10; i++){
      
      
        let number = i * input;
      
      rezultat = rezultat + i.toString()  + " * " +  input.toString() +  " = " + number + "\n";
      
      console.log(i * input);
    }
    
    rezultat = rezultat.substring(0,rezultat.length -1);
    return rezultat;
  }
  //https://www.codewars.com/kata/5a2fd38b55519ed98f0000ce/train/javascript/60efeee323e2e000198ae6b6


  /**Bob is a chicken sexer. His job is to sort baby chicks into a Male(M) and Female(F) piles. When bob can't guess can throw his hands up and declare it with a '?'.

Bob's bosses don't trust Bob's ability just yet, so they have paired him with an expert sexer. All of Bob's decisions will be checked against the experts choices to generate a correctness score.

Scoring Rules
When they agree, he gets 1 point.
When they disagree but one has said '?', he gets 0.5 points.
When they disagree completely, he gets 0 points. */
function correctness(bobsDecisions, expertDecisions) {
  
    if(bobsDecisions.length != expertDecisions.length)
      return 0;
    
    let score = 0;
    
    for(let i = 0; i < bobsDecisions.length; i++){
        
      if(bobsDecisions[i] == expertDecisions[i]){
        
        score = score + 1;
      }
      else if(bobsDecisions[i] == '?' || expertDecisions[i] == '?'){
        score = score + 0.5;
      }
    }
    
     return score;
  }
  //https://www.codewars.com/kata/57ed40e3bd793e9c92000fcb/train/javascript/60f5ae924bb4ea001481b975


  /**Task
You will be given an array of numbers. You have to sort the odd numbers in ascending order while leaving the even numbers at their original positions.

Examples
[7, 1]  =>  [1, 7]
[5, 8, 6, 3, 4]  =>  [3, 8, 6, 5, 4]
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]  =>  [1, 8, 3, 6, 5, 4, 7, 2, 9, 0] */

function sortArray(array) {
  
    let oddNums = [];
    
    console.log(array);
    
    for(let i = 0; i < array.length; i++) {
      
      if(array[i] % 2 != 0) {
        
        oddNums.push(array[i]);
      }
    }
    
    oddNums.sort((a,b) => a-b);
    
    let counter = 0;
    
    for(let i = 0; i < array.length; i++) {
      
      if(array[i] % 2 !=0){
        
        array[i] = oddNums[counter];
        counter ++;
      }
    }
    
    console.log(array);
    
    return array;
    
  }
  //https://www.codewars.com/kata/578aa45ee9fd15ff4600090d/train/javascript/60f05a9d8fd43a0007a48627
  
  /**Given an array of integers, find the one that appears an odd number of times.

There will always be only one integer that appears an odd number of times. */
function findOdd(A) {
    let count = 0;
    let arr = A.sort((a, b) => a - b);
    for (let i = 0; i < arr.length; i++) {
      for (let j = 0; j < arr.length; j++) {
        if (arr[i] == arr[j]) {
          count++;
        }
      }
      if (count % 2 !== 0) {
        return arr[i];
      }
    }
  }
  //https://www.codewars.com/kata/54da5a58ea159efa38000836/train/javascript/60f1b271539c06003ecf9742

  /**You are given a string of letters and an array of numbers.
The numbers indicate positions of letters that must be removed, in order, starting from the beginning of the array.
After each removal the size of the string decreases (there is no empty space).
Return the only letter left.

Example:

let str = "zbk", arr = [0, 1]
    str = "bk", arr = [1]
    str = "b", arr = []
    return 'b'
Notes
The given string will never be empty.
The length of the array is always one less than the length of the string.
All numbers are valid.
There can be duplicate letters and numbers. */
function lastSurvivor(letters, coords) {
    letters = letters.split('');
    for (let i = 0; i < coords.length; i++) {
       letters.splice(coords[i], 1)
    }
    return letters.join('')
 }

//https://www.codewars.com/kata/609eee71109f860006c377d1/train/javascript/60f05330c3173900521c0bb9


/**Just a simple sorting usage. Create a function that returns the elements of the input-array / list sorted in lexicographical order. */


sortme = function( names ){
    return names.sort()
  }
  //https://www.codewars.com/kata/51f41b98e8f176e70d0002a8/train/javascript/60f059888fd43a0044a5e35b

  /**Function receive a two-dimensional square array of random integers. On the main diagonal, all the negative integers must be changed to 0, while the others must be changed to 1 (Note: 0 is considered non-negative, here).

(You can mutate the input if you want, but it is a better practice to not mutate the input)

Example:

Input array

[
  [-1,  4, -5, -9,  3 ],
  [ 6, -4, -7,  4, -5 ],
  [ 3,  5,  0, -9, -1 ],
  [ 1,  5, -7, -8, -9 ],
  [-3,  2,  1, -5,  6 ]
]
Output array

[
  [ 0,  4, -5, -9,  3 ],
  [ 6,  0, -7,  4, -5 ],
  [ 3,  5,  1, -9, -1 ],
  [ 1,  5, -7,  0, -9 ],
  [-3,  2,  1, -5,  1 ]
] */
function matrix(array) {
    for (var i = 0 ; i < array.length ; i++){
      if (array[i][i] < 0)
        array[i][i] = 0;
      else
        array[i][i] = 1;
    }
    return array;
   }
   //https://www.codewars.com/kata/581214d54624a8232100005f/train/javascript/60f053028fd43a0032a346ee

   /**This Kata is intended as a small challenge for my students

Create a function, called insurance(), that computes the cost of renting a car. The function takes 3 arguments: the age of the renter, the size of the car, and the number days for the rental. The function should return an integer number of the calculated total cost of the rental.

Age (integer) : There is a daily charge of $10 if the driver is under 25

Car Size (string) : There may be an additional daily charge based on the car size:

car size surcharge "economy" $0 "medium" $10 "full-size" $15

Rental Days (integer) : There is a base daily charge of $50 for renting a car. Simply multiply the one day cost by the number of days the car is rented in order to get the full cost.

Note: Negative rental days should return 0 cost. Any other car size NOT listed should come with a same surcharge as the "full-size", $15.

insurance(18, "medium", 7); // => 490
insurance(30,"full-size",30); // => 1950
insurance(21,"economy",-10); // => 0
insurance(42,"my custom car",7); // => 455 */

function insurance(age, size, numofdays){
  
    if(numofdays <= 0){
       return 0;
     }
     
       var price = 50;
     
     if(age < 25) {
       price = price + 10;
     }
     
     if(size == "economy"){ 
       price = price + 0;
     }
     else if(size == "medium"){
       price = price + 10;
     }
     else if(size == "full-size"){ 
       price = price + 15;
     }
     else{ 
       price = price + 15;
     }
     
     return price * numofdays;
   }
       
   
//https://www.codewars.com/kata/586430a5b3a675296a000395/train/javascript/60f010db8fd43a003e9cd288

/**Return an array containing the numbers from 1 to N, where N is the parametered value.

Replace certain values however if any of the following conditions are met:

If the value is a multiple of 3: use the value "Fizz" instead
If the value is a multiple of 5: use the value "Buzz" instead
If the value is a multiple of 3 & 5: use the value "FizzBuzz" instead
N will never be less than 1.

Method calling example:

fizzbuzz(3) -->  [1, 2, "Fizz"] */
function fizzbuzz(n) {
    var list=[];
    for(var i = 1; i <=n; i++){
     if(i%3 == 0 && i%5 == 0){
       list.push("FizzBuzz");
       continue;   
     }
      if(i%3 == 0){
         list.push("Fizz");
       continue;  
      }
       if(i%5 == 0){
         list.push("Buzz");
       continue;  
      }
      list.push(i);
    }
    return list;
       
  }
  //https://www.codewars.com/kata/5300901726d12b80e8000498/train/javascript/60f008ea539c06003ea65f57

  /** this kata you should simply determine, whether a given year is a leap year or not. In case you don't know the rules, here they are:

years divisible by 4 are leap years
but years divisible by 100 are not leap years
but years divisible by 400 are leap years
Additional Notes:

Only valid years (positive integers) will be tested, so you don't have to validate them
Examples can be found in the test fixture. */
function isLeapYear(year) {
    if(0 == year%400) return true;
    if(0 == year%100) return false;
    if(0 == year%4) return true;
    return false;
  }
  //https://www.codewars.com/kata/526c7363236867513f0005ca/train/javascript/60f0048b75ab7f00312e9523
  


  /**Deoxyribonucleic acid (DNA) is a chemical found in the nucleus of cells and carries the "instructions" for the development and functioning of living organisms.

If you want to know more: http://en.wikipedia.org/wiki/DNA

In DNA strings, symbols "A" and "T" are complements of each other, as "C" and "G". You have function with one side of the DNA (string, except for Haskell); you need to get the other complementary side. DNA strand is never empty or there is no DNA at all (again, except for Haskell).

More similar exercise are found here: http://rosalind.info/problems/list-view/ (source)

Example: (input: output)

DNAStrand ("ATTGC") // return "TAACG"
DNAStrand ("GTAT") // return "CATA" 
 */
var pairs = {'A':'T','T':'A','C':'G','G':'C'};
function DNAStrand(dna){
  return dna.split('').map(function(v){ return pairs[v] }).join('');
}
//https://www.codewars.com/kata/554e4a2f232cdd87d9000038/train/javascript/60effebf8fd43a001a9a7bb9


/**This kata is the first of a sequence of four about "Squared Strings".

You are given a string of n lines, each substring being n characters long: For example:

s = "abcd\nefgh\nijkl\nmnop"

We will study some transformations of this square of strings.

Vertical mirror: vert_mirror (or vertMirror or vert-mirror)
vert_mirror(s) => "dcba\nhgfe\nlkji\nponm"
Horizontal mirror: hor_mirror (or horMirror or hor-mirror)
hor_mirror(s) => "mnop\nijkl\nefgh\nabcd"
or printed:

vertical mirror   |horizontal mirror   
abcd --> dcba     |abcd --> mnop 
efgh     hgfe     |efgh     ijkl 
ijkl     lkji     |ijkl     efgh 
mnop     ponm     |mnop     abcd  */
function vertMirror(str) {
    return str.split('\n')
      .map(line => line.split('').reverse().join(''))
      .join('\n')
}
function horMirror(str) {
    return str.split('\n')
      .reverse()
      .join('\n')
}
function oper(fct, s) {
    return fct(s)
}
//https://www.codewars.com/kata/56dbe0e313c2f63be4000b25/train/javascript/60eff4c38fd43a000798b4fd

/**Count the number of divisors of a non-negative integer n.

Random tests go up to n = 500000.

Examples
divisors(4)  = 3  // 1, 2, 4
divisors(5)  = 2  // 1, 5
divisors(12) = 6  // 1, 2, 3, 4, 6, 12
divisors(30) = 8  // 1, 2, 3, 5, 6, 10, 15, 30 */
function getDivisorsCnt(n){
    var div = 0;
  for(var i = 1; i <= n; i++) if(n % i == 0) div++;
  return div;
}
//https://www.codewars.com/kata/542c0f198e077084c0000c2e/train/javascript/60efef9123e2e0000a8bf1ad

/**This code does not execute properly. Try to figure out why. */
public class Multiply {
    public static Double multiply(Double a, Double b) {
        return a * b;
    }
}

//https://www.codewars.com/kata/50654ddff44f800200000004/train/java/602fbdaa505ad10021362a87
  